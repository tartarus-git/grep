// Memory usage.
#define INPUT_STREAM_BUFFER_MAX_SIZE (8129 * 1024)					// 8 MG
#define INPUT_STREAM_BUFFER_START_SIZE 8192							// NOTE: Popular file sys block sizes (aka. logical block sizes) are 4KB and 8KB. We start the buffer at 8KB and scale with 8KB until a max size of 8MG.
#define INPUT_STREAM_BUFFER_SIZE_STEP 8129							// NOTE: This is to try to get the buffer to be a multiple of file sys block size. This system works great for block sizes under 8KB too because the block sizes are in powers of two and 8KB covers the alignment fo 4KB perfectly.

// NOTE: AFAIK, the file system block size is a unit of work for the file system. File reads are done in blocks which are the size of the file system block size.
// If the buffer isn't a multiple of the file system block size, we could end up reading way more data from the file than we need (1 extra block), even if we're just a couple of bytes
// over the nearest block size multiple. We try to avoid that by tuning the values. It's essentially the same deal as with memory alignment in programming, we want to optimize it to avoid unnecessary reads.
// NOTE: The block size of the underlying device (HDD or SSD for example) is often 512 bytes, but the logical (file system) block size is often bigger (4 or 8 KB). It is often the same as the page size for virtual memory.

// TODO: Technically, it would be optimal to just straight up read the block size from the OS, you would just have to implement it two times (Windows and Linux). Shouldn't be too hard though, consider doing it in the future.

#define HISTORY_BUFFER_MAX_LINE_COUNT 63																				// Maximum num of lines storable in history buffer when using --context x flag. Note that the count of history buffer is HISTORY_BUFFER_MAX_LINE_COUNT + 1 because of circular buffer.

// TODO: Make absolutely sure that I'm not including too much.

#include <csignal>																										// Signalling and polling things.
#ifndef PLATFORM_WINDOWS
#include <sys/signalfd.h>
#include <poll.h>
#endif

#ifdef PLATFORM_WINDOWS
#define WIN32_LEAN_AND_MEAN																								// Include Windows.h to get access to the few winapi functions that we need, such as the ones for getting console input handle and setting ANSI escape code support.
#include <Windows.h>
#endif

#include <cstdlib>																										// Needed for realloc function.

#ifdef PLATFORM_WINDOWS
#include <io.h>																											// Needed for _isatty function.
#define isatty(x) _isatty(x)																							// Renaming _isatty to isatty so it's the same as the function call in Linux.
#define crossplatform_write(...) _write(__VA_ARGS__)
#else
#include <unistd.h>																										// Linux isatty function is in here as well as some other useful stuff for this program as well I think.
#define crossplatform_write(...) write(__VA_ARGS__)
#endif

#include <chrono>																										// For access to time durations for use with sleep_for().
#include <thread>																										// For access to std::this_thread::sleep_for() and std::this_thread::yield().

#include <cstdio>																										// NOTE: Use "c___" headers instead of "____.h" headers whenever possible. The "c___" counterparts minimize global scope pollution by putting a lot of things in namespaces and replacing some #defines with functions. It's more "correct".
#include <iostream>
#include <cstring>
#include <string>
#include <regex>

#ifdef PLATFORM_WINDOWS																									// These #defines are already defined in one of the Linux-only headers, but for Windows, we need to explicitly do it.
#define STDIN_FILENO 0
#define STDOUT_FILENO 1
#define STDERR_FILENO 2
#endif

/*

NOTE: I've just learned about compiler intrinsics and SIMD and such and I'm going to write it here so I have a reference for later and don't forget:
So SIMD is often mentioned as a way to speed up computations and you should be aware of it so that you might use it in the future to speed up some of your algorithms.
IMPORTANT: A fair amount of SIMD instructions are already generated by the compiler when compiling normal code, because the compiler will optimize things that it can do better with SIMD. That means that you need not worry for a lot of calculations, because the optimizer has your back AFAIK.
SIMD stands for Single Instruction Multiple Data. It means that, rather than operating on one word or one unit of data per instruction, one instruction will alter a whole array (vector) of words or units in one go. This is awesome because it requires the same amount of time but can make your programs
a lot faster (potentially). That means, that for a lot of simple additions and multiplications and what not inside of functions, you're actually wasting processing power because you could be doing four at a time.
Obviously, that means that you should theoretically use SIMD everywhere, but that would be a major hassle and potentially screw up some of your cross platform-ness. For those simple optimizations, I would think it would be pretty safe to rely on the compiler to group and optimize certain calculations.
SIMD is super useful for stuff like going through arrays with loops. The practice of loop unrolling already exists to make this process more efficient (calculating four elements and then moving on to the next four for example), but this can be made even better by having those four elements be handled by a single SIMD
instruction.
IMPORTANT: If the heavy lifting inside of your algorithms is done using standard library functions, you can rest easy AFAIK, because they are most likely implemented as efficiently as possible and are tailored to your system. That means SIMD is most likely used to it's full potential in those functions.
There are different instructions sets that got added to CPU's over the years, each expanding the SIMD functionality of the CPU's. For example, SSE (Streaming SIMD Extentions) is one of those, it has different versions as well.
You can basically rely on the fact that CPU's are super backwards compatible and that if a SIMD instruction set was once implemented, it will still be there along with whatever new instruction sets have been added since.
IMPORTANT: SIMD is not cross platform technically, you have to specialize your code to use a specific SIMD instruction set, which depends on the architecture that you are using. In practice, this doesn't matter all too much because, if you choose an instruction set that is old enough (doesn't even have to be that old),
it'll be supported by all the CPU's that you would ever really want to run your code on.
To use a SIMD instruction set, you have to include the required header. This header will be filled with what are known as compiler intrinsics, which are, AFAIK, functions that are specific to the compiler and, in this case, translate directly into SIMD instructions.
There are different headers for different instruction sets, you have to google around to find the one you want to use. The recommended one for standard SIMD stuff is immintrin.h.
The header exists for both MSVC and gcc and includes all the other headers you would probably want, which means it includes basically all the other instruction sets. The header will be made available if the intrinsics are available for the system you are compiling for.
Since this header has so many different versions, it will always be available AFAIK, some intrinsics inside may not be available though because they might not be supported AFAIK.
The documentation for this stuff is lacking in my opinion, so researching is a slight pain, but it is very much worth it to implement SIMD instructions if you come across the right spot in code, because it could dramatically speed up your processing.

Heres an interesting way to look at things:
Normal CPU instructions --> super linear, theoretically not vectorized (they don't behave like SIMD instructions), although I'm not sure how many normal instructions make use of vectorization, it does seems to be the way CPU's are heading.
SIMD instructions --> useful, but relatively minimal vectorization (usually 4 or 8 words per instruction AFAIK)
GPU code with OpenCL for example --> A huge amount of computations at the same time, not because of instructions that manipulate multiple data, but because of the crazy amount of CPU cores.
The three types of programming can sort of be seen as in a heirarchy or a ladder or something. Why would you ever use SIMD over OpenCL? SIMD has so much less overhead than queueing kernels in OpenCL AFAIK. SIMD is super useful when you want to vectorize small amounts of things.
If you want to process a huge array in parallel, GPU computing is the way to go, instead of using SIMD.

Another concept that builds on SIMD: SWAR (SIMD Within A Register):
Very simple AFAIK. It is basically just more instructions, which also act like SIMD instructions, but they use data units that are smaller than normal for example (or registers that are larger than normal), to process multiple data within the one register.
Effectively does the same thing as SIMD, I'm not really sure why it warrants it's own acronym.

Beneifts of SWAR over SIMD: The benefits come only from the fact that, through sacrificing resolution of your values (moving from whole words to partial words), you can process more values in parallel AFAIK, which is faster.

*/

#define static_strlen(x) (sizeof(x) - 1)

// ANSI escape code helpers.
#define ANSI_ESC_CODE_PREFIX "\033["
#define ANSI_ESC_CODE_SUFFIX "m"
#define ANSI_ESC_CODE_MIN_SIZE (static_strlen(ANSI_ESC_CODE_PREFIX) + static_strlen(ANSI_ESC_CODE_SUFFIX))

const char* helpText = "grep accepts text as input and outputs the lines from the input that have the specified keyphrase in them\n" \
					   "\n" \
					   "usage: grep [-calv] [--context <amount> || --only-line-nums || --stdout-color <auto|on|off> || --stderr-color <auto|on|off>] <regex keyphrase>\n" \
					   "       grep <--help || --h>            -->            shows help text\n" \
					   "\n" \
					   "arguments:\n" \
							"\t-c							   -->         be case sensitive when matching\n" \
							"\t-a                              -->         print all lines from input but still color matches\n" \
							"\t-l                              -->         print line numbers\n" \
							"\t-v                              -->         invert output - print lines that would normally be omitted and omit lines that would normally be printed\n" \
							"\t--context <amount>              -->         print the specified amount of context (in lines) around each matched line\n" \
							"\t--only-line-nums                -->         print only the line numbers, not the actual lines\n" \
							"\t--stdout-color <auto|on|off>    -->         force a specific stdout coloring behaviour, auto is default\n" \
							"\t--stderr-color <auto|on|off>    -->         force a specific stderr coloring behaviour, auto is default\n";

// Flag to keep track of whether we should color output or not.
bool isOutputColored;
bool isErrorColored;

// Output coloring.
namespace color {
	const char* const red = ANSI_ESC_CODE_PREFIX "31" ANSI_ESC_CODE_SUFFIX;
	const char* const reset = ANSI_ESC_CODE_PREFIX "0" ANSI_ESC_CODE_SUFFIX;
}

// SIDE-NOTE: const char* const instead of const char* doesn't always work. In the cases where you intend to change what the const char* pointer points to, const char* allows that while const char* const doesn't. In this case, const char* const is absolutely fine, but a lot of people still don't write it because personal preference and style.

// This function makes it easy to report errors. It handles the coloring for you, as well as the formatting of the error string.
template <size_t N>
void reportError(const char (&msg)[N]) {
	if (isErrorColored) {
		// Construct a buffer to hold the finished error message.
		char buffer[static_strlen(color::red) + static_strlen("ERROR: ") + N - 1 + static_strlen(color::reset) + 1];							// NOTE: This code block is to create our own specific buffering for these substrings, to avoid syscalls and make the whole thing as efficient as possible.

		// Copy in the ANSI code for red color.
		std::memcpy(buffer, color::red, static_strlen(color::red));																		// NOTE: Technically, it would be more efficient to write "ERROR: " in every error message individually, but that probably means the executable is larger because of the extra .rodata data, which is undesirable.

		// Copy in the ERROR tag.
		std::memcpy(buffer + static_strlen(color::red), "ERROR: ", static_strlen("ERROR: "));									// NOTE: memcpy is the C-style version of the function and std::memcpy is the C++-style version of the function. They're both literally the same function in every single way, but I'm going to use std because it's more "proper".

		// Copy in the actual error message.
		std::memcpy(buffer + static_strlen(color::red) + static_strlen("ERROR: "), msg, N - 1);

		// Copy in the ANSI code for color reset.
		std::memcpy(buffer + static_strlen(color::red) + static_strlen("ERROR: ") + N - 1, color::reset, static_strlen(color::reset));

		// Add a newline to the end of the message.
		buffer[static_strlen(color::red) + static_strlen("ERROR: ") + N - 1 + static_strlen(color::reset)] = '\n';

		// Write the message to stdout.
		crossplatform_write(STDERR_FILENO, buffer, sizeof(buffer));									// Don't buffer the output, we would technically have to if other buffered output would have happened till this point, but errors almost always happen before any buffered output, so this is safe.
		// TODO: Write about how we don't have to catch any errors here.
		return;
	}
	// Uncolored version of the error message generation.
	char buffer[static_strlen("ERROR: ") + N - 1 + 1];
	std::memcpy(buffer, "ERROR: ", static_strlen("ERROR: "));
	std::memcpy(buffer + static_strlen("ERROR: "), msg, N - 1);
	buffer[static_strlen("ERROR: ") + N - 1] = '\n';
	crossplatform_write(STDERR_FILENO, buffer, sizeof(buffer));					// TODO: Why does intellisense want something from me here?
}

void reportRegexError(const char* msg) {				// TODO: Finish writing this function for regex error reporting.
	size_t msgLength = std::strlen(msg);

	if (isErrorColored) {
		// Construct a buffer to hold the finished error message.
		size_t bufferSize = static_strlen(color::red) + static_strlen("ERROR: regex error: ") + msgLength + static_strlen(color::reset) + 1;							// NOTE: This code block is to create our own specific buffering for these substrings, to avoid syscalls and make the whole thing as efficient as possible.
		char* buffer = new char[bufferSize];

		// Copy in the ANSI code for red color.
		std::memcpy(buffer, color::red, static_strlen(color::red));																		// NOTE: Technically, it would be more efficient to write "ERROR: " in every error message individually, but that probably means the executable is larger because of the extra .rodata data, which is undesirable.

		// Copy in the ERROR tag.
		std::memcpy(buffer + static_strlen(color::red), "ERROR: regex error: ", static_strlen("ERROR: regex error: "));									// NOTE: memcpy definition exists because Visual Studio puts in an extra header file that lets it be available implicitly. AFAIK, if you want cross-platform and cross-compiler support, you have to use std::memcpy.

		// Copy in the actual error message.
		std::memcpy(buffer + static_strlen(color::red) + static_strlen("ERROR: regex error: "), msg, msgLength);

		// Copy in the ANSI code for color reset.
		std::memcpy(buffer + static_strlen(color::red) + static_strlen("ERROR: regex error: ") + msgLength, color::reset, static_strlen(color::reset));

		// Add a newline to the end of the message.
		buffer[static_strlen(color::red) + static_strlen("ERROR: regex error: ") + msgLength + static_strlen(color::reset)] = '\n';

		// Write the message to stdout.
		crossplatform_write(STDERR_FILENO, buffer, bufferSize);									// Don't buffer the output, we would technically have to if other buffered output would have happened till this point, but errors almost always happen before any buffered output, so this is safe.
		// TODO: Write about how we don't have to catch any errors here.

		delete[] buffer;
		return;
	}
	// Uncolored version of the error message generation.
	size_t bufferSize = static_strlen("ERROR: regex error: ") + msgLength + 1;
	char* buffer = new char[bufferSize];
	std::memcpy(buffer, "ERROR: regex error: ", static_strlen("ERROR: regex error: "));				// TODO: What's wrong here?
	std::memcpy(buffer + static_strlen("ERROR: regex error: "), msg, msgLength);
	buffer[static_strlen("ERROR: regex error: ") + msgLength] = '\n';
	crossplatform_write(STDERR_FILENO, buffer, bufferSize);
}

#ifdef PLATFORM_WINDOWS																// Only needed on Windows because we signal for the main loop to stop in Linux via artifical EOF signal.
bool shouldLoopRun = true;
void signalHandler(int signum) { shouldLoopRun = false; }							// NOTE: SIGINT exists on Windows, but SIGTERM doesn't. SIGTERM is replaced by SIGBREAK on Windows. Also, SIGINT signal handler gets run on a separate thread, unlike the signal handlers for all the other signals. Why? I have no idea.
#endif

// Collection of flags. These correspond to command-line flags you can set for the program.
namespace flags {
	bool caseSensitive = false;
	bool allLines = false;
	bool lineNums = false;
	bool inverted = false;
	bool context = false;
	bool only_line_nums = false;
}

// Keeps track of the current line so a variety of helper functions can do things with it.
size_t lineCounter = 1;

class HistoryBuffer {
	static unsigned int buffer_len;
	static unsigned int beginIndex;

public:
	static std::string* buffer;
	static unsigned int buffer_lastIndex;
	static unsigned int amountFilled;																	// This variable isn't always used, only for specific modes where keeping track of amount of filled slots is the most efficient way.
	static unsigned int index;

	static void incrementAmountFilled() { if (amountFilled != buffer_lastIndex) { amountFilled++; } }

	static void purgeAmountFilled() { amountFilled = 0; }

	static void init() {
		buffer_len = buffer_lastIndex + 1;
		buffer = new std::string[buffer_len];
	}

	static void push() {
		if (index == beginIndex - 1) {
			if (beginIndex == buffer_lastIndex) { index++; beginIndex = 0; return; }
			index++; beginIndex++; return;
		}
		if (index == buffer_lastIndex) { if (beginIndex == 0) { beginIndex = 1; } index = 0; return; }
		index++;
	}

	static void pushWithAmountInc() { push(); if (amountFilled != buffer_lastIndex) { amountFilled++; } }

	static void purge() { index = beginIndex; }

	static void purgeWithAmountSet() { purge(); purgeAmountFilled(); }

	static void print() { for ( ; beginIndex != index; beginIndex = (beginIndex == buffer_lastIndex ? 0 : beginIndex + 1)) { std::cout << buffer[beginIndex] << '\n'; } }			// NOTE: It is important to use '\n' instead of std::endl because std::endl puts a newline into the stream but also flushes it, which is a syscall, which is super slow. '\n' doesn't flush, so faster.

	// NOTE: We could store the amount filled and edit the variable with every call to push(), but I doubt that would be efficient since push is called so many more times than print is (at least normally).
	// Doing that would cause amountFilled to be added to over and over with little return on the investment. That's why we're just calculating amountFilled every time we need it, that way push() doesn't have to waste it's time incrementing anything.
	// NOTE: The exceptions to that rule are the peek functions. They're used for flags::inverted, where it's reasonable to cache amountFilled, so we do it there. Not for normal prints though.
	// NOTE: Another exception to that rule is flags::only_line_nums. There, the circular buffer isn't used and amountFilled is also the most efficient way of handling things. This is the case for printLineNums() and a couple functions at the top of the class.
	static unsigned int calculateAmountFilled() { return index > beginIndex ? index - beginIndex : buffer_len - beginIndex + index; }

	static void printLinesWithLineNums() {
		if (index == beginIndex) { return; }
		lineCounter -= calculateAmountFilled();
		std::cout << lineCounter << ' ' << buffer[beginIndex] << '\n';
		lineCounter++;
		beginIndex = (beginIndex == buffer_lastIndex ? 0 : beginIndex + 1);
		for ( ; beginIndex != index; beginIndex = (beginIndex == buffer_lastIndex ? 0 : beginIndex + 1), lineCounter++) { std::cout << lineCounter << ' ' << buffer[beginIndex] << '\n'; }
	}

	static void lastPrintLineNums() { for (size_t historyLine = lineCounter - amountFilled; historyLine < lineCounter; historyLine++) { std::cout << historyLine << '\n'; } }
	static void printLineNums() { lastPrintLineNums(); purgeAmountFilled(); }

	static bool peekSafestLine(std::string& safestLine) { if (amountFilled == buffer_lastIndex) { safestLine = buffer[beginIndex]; return true; } return false; }

	static bool peekSafestLineNum(size_t& safestNum) { if (amountFilled == buffer_lastIndex) { safestNum = lineCounter - buffer_lastIndex; return true; } return false; }

	static void release() { delete[] buffer; }
};

std::string* HistoryBuffer::buffer;
unsigned int HistoryBuffer::buffer_len;
unsigned int HistoryBuffer::index = 0;
unsigned int HistoryBuffer::beginIndex = 0;
unsigned int HistoryBuffer::buffer_lastIndex;
unsigned int HistoryBuffer::amountFilled = 0;

// SIDE-NOTE: While writing the testing system for this program, I stumbled on a bunch of issues. The main problem was that powershell doesn't just pipe the data to and from programs. It will split it on the newlines and construct a list of strings that it will pass to and from programs.
// I don't exactly know why, probably because Powershell deals with objects instead of raw data when it transfers data, so it tries to convert between the two.
// This was one of the super cool things about powershell that was advertised, but it's kind of stupid in a lot of scenarios. Anyway, when piping the string array into another program, powershell concatinates the strings into one giant string that just has a lot of lines.
// It would be cool if this string was the same as the original string that powershell accepted from this grep program, but it sadly isn't in some cases. The strings are all fitted with a line ending at the end. This is a huge issue when you're trying to write a line that doesn't end the line at the end.
// For me, this became an issue when I tried to write an ANSI escape code for resetting the text color after the last newline. Powershell put another newline at the end, making there be an extra line at the end of the output file.
// To solve this, I just wrote the testing system in C++ and did the piping myself. Powershell just wasn't cutting it. Anyway, it's important that you remember this behaviour that you experienced while doing this project.
// Also, powershell behaves weird in other ways as well. The Out-File and the > and >> operators all write data in 16-bit wide format, which means half your file is just NUL characters. Really stupid but that's the way it goes. You can override this with the -Encoding ascii flag on Out-File, but the > and >> operators just aren't changeable.

// Parse a single flag group. A flag group is made out of a bunch of single letter flags.
void parseFlagGroup(char* arg) {
	for (int i = 0; ; i++) {
		switch (arg[i]) {
		case 'c': flags::caseSensitive = true; break;
		case 'a': flags::allLines = true; break;
		case 'l': flags::lineNums = true; break;
		case 'v': flags::inverted = true; break;
		case '\0': return;
		default:
			reportError("one or more flag arguments are invalid");
			exit(EXIT_SUCCESS);
		}
	}
}

// Adds a character to the end of an unsigned integer.
bool addToUInt(unsigned int& value, char character) {
	if (character < '0' || character > '9' ) { return false; }
	value = value * 10 + (character - '0');
	return true;
}

unsigned int parseUInt(char* string) {
	unsigned int result = 0;
	if (string[0] != '\0') {
		if (addToUInt(result, string[0])) {
			for (int i = 1; ; i++) {
				if (addToUInt(result, string[i])) { continue; }
				if (string[i] == '\0' && result <= HISTORY_BUFFER_MAX_LINE_COUNT) { return result; }
				break;
			}
		}
	}
	reportError("invalid value for --context flag");
	exit(EXIT_SUCCESS);
}

void showHelp() { std::cout << helpText; }				// NOTE: I have previously only shown help when output is connected to TTY, so as not to pollute stdout when piping. Back then, help was shown sometimes when it wasn't requested, which made it prudent to include that feature. Now, you have to explicitly ask for help, making this TTY branching unnecessary.

bool forcedOutputColoring;
bool forcedErrorColoring;// NOTE: GARANTEE: If something goes wrong while parsing the cmdline args and an error message is necessary, the error message will always be printed with the default error coloring (based on TTY/piped mode).

// Parse flags at the argument level. Calls parseFlagGroup if it encounters flag groups and handles word flags (those with -- in front) separately.
unsigned int parseFlags(int argc, char** argv) {																// NOTE: If you write --context twice or --stdout-color or --stderr-color twice (or any additional flags that we may add), the value supplied to the rightmost instance will be the value that is used. Does not throw an error.
	for (int i = 1; i < argc; i++) {
		const char* arg = argv[i];
		if (arg[0] == '-') {
			if (arg[1] == '-') {
				const char* flagTextStart = arg + 2;
				if (*flagTextStart == '\0') { continue; }

				if (!strcmp(flagTextStart, "context")) {
					i++;
					if (i == argc) {
						reportError("the --context flag was not supplied with a value");
						exit(EXIT_SUCCESS);
					}
					HistoryBuffer::buffer_lastIndex = parseUInt(argv[i]);
					if (HistoryBuffer::buffer_lastIndex == 0) { continue; }															// Context value 0 is the same as no context, so don't bother setting context up.
					flags::context = true;
					continue;
				}

				if (!strcmp(flagTextStart, "only-line-nums")) { flags::only_line_nums = true; continue; }

				if (!strcmp(flagTextStart, "stdout-color")) {
					i++;
					if (i == argc) {
						reportError("the --stdout-color flag was not supplied with a value");
						exit(EXIT_SUCCESS);
					}
					if (!strcmp(argv[i], "on")) { forcedOutputColoring = true; continue; }
					if (!strcmp(argv[i], "off")) { forcedOutputColoring = false; continue; }
					if (!strcmp(argv[i], "auto")) { forcedOutputColoring = isOutputColored; continue; }
					reportError("invalid value for --stdout-color flag");
					exit(EXIT_SUCCESS);
				}

				if (!strcmp(flagTextStart, "stderr-color")) {
					i++;
					if (i == argc) {
						reportError("the --stderr-color flag was not supplied with a value");
						exit(EXIT_SUCCESS);
					}
					if (!strcmp(argv[i], "on")) { forcedErrorColoring = true; continue; }
					if (!strcmp(argv[i], "off")) { forcedErrorColoring = false; continue; }
					if (!strcmp(argv[i], "auto")) { forcedErrorColoring = isErrorColored; continue; }
					reportError("invalid value for --stderr-color flag");
					exit(EXIT_SUCCESS);
				}

				if (!strcmp(flagTextStart, "help")) { showHelp(); exit(EXIT_SUCCESS); }
				if (!strcmp(flagTextStart, "h")) { showHelp(); exit(EXIT_SUCCESS); }

				reportError("one or more flag arguments are invalid");
				exit(EXIT_SUCCESS);
			}
			parseFlagGroup(argv[i] + 1);
			continue;
		}
		return i;																									// Return index of first arg that isn't flag arg. Helps calling code parse args.
	}
	return argc;																									// No non-flag argument was found. Return argc because it works nicely with calling code.
}

std::regex keyphraseRegex;

// Arg management function. Handles some argument parsing but pushes flag parsing to parseFlags.
void manageArgs(int argc, char** argv) {
	unsigned int keyphraseArgIndex = parseFlags(argc, argv);														// Parse flags before doing anything else.
	switch (argc - keyphraseArgIndex) {
	case 0:
		reportError("too few arguments");
		exit(EXIT_SUCCESS);
	case 1:
		{																												// Unnamed namespace because we can't create variables inside switch cases otherwise.
			std::regex_constants::syntax_option_type regexFlags = std::regex_constants::grep | std::regex_constants::nosubs | std::regex_constants::optimize;
			if (!flags::caseSensitive) { regexFlags |= std::regex_constants::icase; }
			try { keyphraseRegex = std::regex(argv[keyphraseArgIndex], regexFlags); }								// Parse regex keyphrase.
			catch (const std::regex_error& err) {																	// Catch any errors relating to keyphrase regex syntax and report them.
				reportRegexError(err.what());
				exit(EXIT_SUCCESS);
			}

			bool previousColoring = isOutputColored;
			isOutputColored = forcedOutputColoring;																		// If everything went great with parsing the cmdline args, finally set output coloring to what the user wants it to be. It is necessary to do this here because of the garantee that we wrote above.
			forcedOutputColoring = previousColoring;

			previousColoring = isErrorColored;
			isErrorColored = forcedErrorColoring;
			forcedErrorColoring = previousColoring;				// TODO: This code block isn't strictly necessary, so you should probably remove it.
		}
		return;
	default:																										// If more than 1 non-flag argument exists (includes flags after first non-flag arg), throw error.
		reportError("too many arguments");
		exit(EXIT_SUCCESS);
	}
}

// Handles input in a buffered way.
class InputStream {
#ifdef PLATFORM_WINDOWS
public:
	static void init() { std::cin.sync_with_stdio(false); }															// Unsynchronize C++ input buffer with C input buffer. This often makes things faster because implementors often don't bother buffering input until this is set to false (where they can then safely buffer input).
#else
	static pollfd fds[2];																							// File descriptors to poll. One for stdin and one for a signal fd.
	static sigset_t sigmask;																						// Signals to handle with poll.

	static char* buffer;
	static size_t bufferSize;

	static ssize_t bytesRead;																						// Position of read head in buffer.
	static ssize_t bytesReceived;																					// Position of write head in buffer.

public:
	static void init() {
		buffer = new char[bufferSize];																				// Initialize buffer with the starting amount of RAM space.
		
		// Add SIGINT and SIGTERM to set of tracked signals.
		if (sigemptyset(&sigmask) == -1) { goto errorBranch; }
		if (sigaddset(&sigmask, SIGINT) == -1) { goto errorBranch; }
		if (sigaddset(&sigmask, SIGTERM) == -1) { goto errorBranch; }

		// Block the set of tracked signals from being handled by default by thread because obviously we're handling them.
		if (sigprocmask(SIG_BLOCK, &sigmask, nullptr) == -1) { goto errorBranch; }

		// Create new file descriptor. Makes a read available when one of the tracked signals is caught.
		{
			int sigfd = signalfd(-1, &sigmask, 0);
			fds[1].fd = sigfd;																						// Add sigfd to list of to be polled file descriptors, so we can be notified if we get a signal from poll. It doesn't matter if it's -1 because on failure we set it to that anyway.
			return;
		}

errorBranch:	fds[1].fd = -1;																						// Tell poll to ignore the now unused entry in fds because some error prevented us from setting it up correctly.
	}

	// NOTE: I think we probably could have just used the standard input buffering mechanisms (while retaining the ability to adjust buffer size) instead of building our own.
	// NOTE: That would probably be faster since the standard is optimized for each platform. I'm too proud of my mechanism to remove it right now, so I'm leaving it in for the forseeable future.
	// NOTE: Plus, I haven't done any benchmarks. Maybe this is faster than the standard because the standard might do a bunch of safety checks and unnecessary stuff.

	static bool refillBuffer() {
		// When no more data left in buffer, try get more.
		if (poll(fds, 2, -1) == -1) {																				// Block until we either get some input on stdin or get either a SIGINT or a SIGTERM.
			if (!color::red) { color::initErrorColoring(); }
			std::cout << color::red << "ERROR: failed to poll stdin, SIGINT and SIGTERM\n" << color::reset;
			return false;
		}

		if (fds[1].revents) { return false; }																		// Signal EOF if we caught a signal.

		bytesReceived = read(STDIN_FILENO, buffer, bufferSize);														// Read as much as we can fit into the buffer.

		if (bytesReceived == 0) { return false; }																	// In case of actual EOF, signal EOF.
		if (bytesReceived == -1) {																					// In case of error, log and signal EOF.
			if (!color::red) { color::initErrorColoring(); }
			std::cout << color::red << "ERROR: failed to read from stdin\n" << color::reset;
			return false;

		}
		bytesRead = 0;																								// If new data is read, the read head needs to be reset to the beginning of the buffer.

		// TODO: The below comparison gives warnings on gcc. Makes sense, can we stop comparing two different types here?
		if (bytesReceived == bufferSize) {																			// Make buffer bigger if it is filled with one read syscall. This minimizes amount of syscalls we have to do. Buffer doesn't have the ability to get smaller again, doesn't need to.
			size_t newBufferSize = bufferSize + INPUT_STREAM_BUFFER_SIZE_STEP;					// TODO: There is probably a way to avoid doing this addition when the buffer is at it's max. You need to do some macro magic with divisions and floors to find the exact value you need to stop at in compile-time.
			if (newBufferSize <= INPUT_STREAM_BUFFER_MAX_SIZE) {
				char* newBuffer = (char*)realloc(buffer, newBufferSize);
				if (newBuffer) { buffer = newBuffer; bufferSize = newBufferSize; }
			}
		}

		return true;
	}
#endif

	static bool readLine(std::string& line) {																		// Returns true on success. Returns false on EOF or error in Windows. Returns false on EOF or SIGINT or SIGTERM or error on Linux.
#ifdef PLATFORM_WINDOWS
		if (std::getline(std::cin, line)) { return true; }															// Get line. Technically, eofbit gets set if EOF terminates the line, but we don't worry about that because in that case we have to return true as well.
		// NOTE: Technically, one could put the below line above std::getline, but that would do an unnecessary branch for every readLine in the file. This way, the branch is only tested when it has to be, which induces small overhead at EOF but saves a bunch of overhead in the loops.
		// NOTE: More importantly, that only works if you assume that the last line of the file ends with EOF, but it might end in newline, in which case this is the better way to do it because it doesn't print an extra line at the bottom of the output.
		if (std::cin.eof()) { return false; }																		// If getline fails because we're trying to read at the EOF position (in which case eofbit will be set), return false without doing error reporting.
			// Otherwise, some error occurred and we need to report it and return false.
		reportError("failed to read from stdin");
		
		return false;

#else
		while (true) {
			for (; bytesRead < bytesReceived; bytesRead++) {														// Read all the data in the buffer.
				if (buffer[bytesRead] == '\n') { bytesRead += 1; return true; }										// Stop when we encounter the end of the current line.
				line += buffer[bytesRead];
			}
			if (refillBuffer()) { continue; }																		// If we never encounter the end of the line in the current buffer, fetch more data.
			return false;																							// If something went wrong while refilling buffer, return false.
		}
#endif
	}

	static bool discardLine() {																						// Reads the next line but doesn't store it anywhere since we're only reading it to advance the read position. Returns true on success. Returns false on EOF or error in Windows. Returns false on EOF, SIGINT, SIGTERM or error on Linux.
#ifdef PLATFORM_WINDOWS
		char character;
		while (true) {																								// Not going to check for shouldLoopRun here because interrupting inside of a line isn't something that readLine offers either and because console is line-buffered anyway, so it wouldn't actually enable signalling while input is pending.
			character = std::cin.get();																				// Processing characters once they've been submitted by user is super fast, so the check would be pretty much unnecessary unless the lines are super super super long, which doesn't happen often.
			if (character == EOF) { return false; }																	// Even if the lines are long, all you'll have to do is press Ctrl+C and wait for the line to be over for grep to quit. This is all so unlikely, that I'm not going to waste a branch checking for it.
			if (std::cin.fail()) {
				reportError("failed to read from stdin");
				return false;
			}
			if (character == '\n') { return true; }
		}
#else
		while (true) {
			for ( ; bytesRead < bytesReceived; bytesRead++) { if (buffer[bytesRead] == '\n') { bytesRead += 1; return true; } }						// Read all the data in current buffer and exit as soon as we've discarded an entire line.
			if (refillBuffer()) { continue; }
			return false;
		}
#endif
	}

#ifndef PLATFORM_WINDOWS
	static void release() { delete[] buffer; }
#endif
};

// SUPER IMPORTANT TODO: Why are we not using the same buffering mechanism for windows as for Linux? Something to do with EOF's, but I don't think we understand all the stuff properly when we built this. The whole InputStream class could be improved. Do that.
// FOLLOWUP: Yeah, I don't think we understood properly at the time of writing the current system. Yes, we don't really have a way to let SIGINT and such interrupt our read calls, but we don't have to rely on std::cin buffering system, which might not be optimal since it doesn't expand as much as ours.
// There is no reason why we should use the same buffering system that we have for linux for the windows version.

#ifndef PLATFORM_WINDOWS																							// Static members variables only need to be initialized in Linux because we don't have any in Windows.
pollfd InputStream::fds[] = { STDIN_FILENO, POLLIN, 0, 0, POLLIN, 0 };												// Parts of this data get changed later in runtime.
sigset_t InputStream::sigmask;

char* InputStream::buffer;
size_t InputStream::bufferSize = INPUT_STREAM_BUFFER_START_SIZE;

ssize_t InputStream::bytesRead = 0;
ssize_t InputStream::bytesReceived = 0;
#endif

std::smatch matchData;

#define CURRENT_LINE_ALIAS HistoryBuffer::buffer[HistoryBuffer::index]

void highlightMatches() {																							// I assume this will be inlined. Probably not in debug mode, but almost definitely in release mode.
	do {
		ptrdiff_t matchPosition = matchData.position();
		std::cout.write(CURRENT_LINE_ALIAS.c_str(), matchPosition);
		std::cout << color::red;
		std::cout.write(CURRENT_LINE_ALIAS.c_str() + matchPosition, matchData.length());
		std::cout << color::reset;
		CURRENT_LINE_ALIAS = matchData.suffix();
	} while (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex));
}

// A couple of #defines to help reduce code bloat in the coming sections of the program.

#ifdef PLATFORM_WINDOWS
#define MAIN_WHILE InputStream::init(); while (shouldLoopRun)
#else
#define MAIN_WHILE InputStream::init(); while (true)
#endif

#define LINE_WHILE_START MAIN_WHILE { if (!InputStream::readLine(CURRENT_LINE_ALIAS)) { break; }
#ifdef PLATFORM_WINDOWS
#define LINE_WHILE_END(cleanupCode) } cleanupCode; HistoryBuffer::release(); return 0;								// NOTE: As per the standard, you can use function-style macros while leaving one or more or all of the parameters blank. They just won't be filled with anything and you'll have empty spots, which is exactly the behaviour we want here, so everythings fine.
#else
#define LINE_WHILE_END(cleanupCode) CURRENT_LINE_ALIAS.clear(); } cleanupCode; InputStream::release(); HistoryBuffer::release(); return 0;
#endif

#define COLORED_RED_ONLY_LINE_WHILE_START std::cout << color::red; LINE_WHILE_START
#define COLORED_RED_ONLY_LINE_WHILE_END() LINE_WHILE_END(std::cout << color::reset)

#ifdef PLATFORM_WINDOWS
#define LINE_WHILE_CONTINUE continue;
#else
#define LINE_WHILE_CONTINUE CURRENT_LINE_ALIAS.clear(); continue;
#endif

#ifdef PLATFORM_WINDOWS
#define INNER_WINDOWS_SIGNAL_CHECK_START if (shouldLoopRun) {
#define INNER_WINDOWS_SIGNAL_CHECK_END } else { HistoryBuffer::release(); return 0; }
#else
#define INNER_WINDOWS_SIGNAL_CHECK_START
#define INNER_WINDOWS_SIGNAL_CHECK_END
#endif

#ifdef PLATFORM_WINDOWS
#define INNER_INPUT_STREAM_READ_LINE if (!InputStream::readLine(CURRENT_LINE_ALIAS)) { HistoryBuffer::release(); return 0; }
#define INNER_INPUT_STREAM_DISCARD_LINE if (!InputStream::discardLine()) { HistoryBuffer::release(); return 0; }
#else
#define INNER_INPUT_STREAM_READ_LINE if (!InputStream::readLine(CURRENT_LINE_ALIAS)) { InputStream::release(); HistoryBuffer::release(); return 0; }
#define INNER_INPUT_STREAM_DISCARD_LINE if (!InputStream::discardLine()) { InputStream::release(); HistoryBuffer::release(); return 0; }
#endif

// NOTE: I'm not going to put any error handling on allocation fails because that shouldn't actually happen unless there is something wrong with the OS. If it does happen, an abort will be triggered and my program will quit, leaving the OS to clean up all of it's resources, which isn't good practice, but like I said, this shouldn't happen and putting in error handling
// NOTE: would be kind of awkward in some places. It would even force me to use exceptions as far as I can see (at the copying of one std::string into another), which I don't want to do.
// NOTE: There is one place where a large enough file would cause memory issues (std::string copying in HistoryBuffer), but I just assume that the user won't put in a huge huge huge file consisting of only one line into a grep program, what would be the use? If he does, then it's his fault and we'll just let the OS clean up, I don't really have a problem with that in that case.
// NOTE: Plus, like I said, it lets me avoid exception handling.

// TODO: Learn about SFINAE and std::enable_if.

// Program entry point
int main(int argc, char** argv) {
	std::cout.sync_with_stdio(false);		// Unsynchronize C++ output buffer with C output buffer. Normally set to true to avoid output getting mixed around when mixing C++ and C function calls in source code. Setting to false yields performance improvements for same reason as doing this for input buffers above.
											// IMPORTANT: As a result of doing this unsync stuff, we have to choose either C or C++ style buffered output and stick with it for the whole program. It is still possible to use C-style input and C++-style output at same time, the limitation only applies within the boundaries of input and output.
#ifdef PLATFORM_WINDOWS
	signal(SIGINT, signalHandler);			// Handling error here doesn't do any good because program should continue to operate regardless.
	signal(SIGTERM, signalHandler);			// Reacting to errors here might poison stdout for programs on other ends of pipes, so just leave this be.
#endif

	// Only enable colors if stdout is a TTY to make reading piped output easier for other programs.
	if (isatty(STDOUT_FILENO)) {
#ifdef PLATFORM_WINDOWS						// On windows, you have to set up virtual terminal processing explicitly and it for some reason disables piping. That's why this group is here.
		HANDLE consoleOutputHandle = GetStdHandle(STD_OUTPUT_HANDLE);
		if (!consoleOutputHandle || consoleOutputHandle == INVALID_HANDLE_VALUE) { goto ANSISetupFailure; }						// If ANSI setup fails, just revert back to not coloring the output, so the user can at least see the output, even if it won't be colored.
		DWORD mode;																												// NOTE: Because of the way this code plays with the rest of the code, the rest of the program will think that the output is being piped to something instead of being attached to a console, but that doesn't matter in this case.
		if (!GetConsoleMode(consoleOutputHandle, &mode)) { goto ANSISetupFailure; }
		if (!SetConsoleMode(consoleOutputHandle, mode | ENABLE_VIRTUAL_TERMINAL_PROCESSING)) { goto ANSISetupFailure; }
#endif

		// NOTE: Technically, it would be more efficient to place the above virtual terminal processing code in places where we are sure that the possibility exists that we can use colors. Not all places satisfy this requirement and the above code thereby technically runs to early and is slightly inefficient in that regard.
		// NOTE: That would require writing it multiple times though and the code wouldn't look as nice.
		// NOTE: Since this overhead is so incredibly small and only transpires one single time, there is essentially no cost, which is why I'm ok with not moving it. SIDE-NOTE: Yes, we could use a function for this, but that still produces less pretty code than the current situation.

		isOutputColored = true;
		forcedOutputColoring = true;
	}
	else {
	ANSISetupFailure:
		isOutputColored = false;
		forcedOutputColoring = false;
	}

	if (isatty(STDERR_FILENO)) {
#ifdef PLATFORM_WINDOWS						// On windows, you have to set up virtual terminal processing explicitly and it for some reason disables piping. That's why this group is here.
		HANDLE consoleOutputHandle = GetStdHandle(STD_ERROR_HANDLE);
		if (!consoleOutputHandle || consoleOutputHandle == INVALID_HANDLE_VALUE) { goto ANSIErrorSetupFailure; }						// If ANSI setup fails, just revert back to not coloring the output, so the user can at least see the output, even if it won't be colored.
		DWORD mode;																												// NOTE: Because of the way this code plays with the rest of the code, the rest of the program will think that the output is being piped to something instead of being attached to a console, but that doesn't matter in this case.
		if (!GetConsoleMode(consoleOutputHandle, &mode)) { goto ANSIErrorSetupFailure; }
		if (!SetConsoleMode(consoleOutputHandle, mode | ENABLE_VIRTUAL_TERMINAL_PROCESSING)) { goto ANSIErrorSetupFailure; }
#endif

		// NOTE: Technically, it would be more efficient to place the above virtual terminal processing code in places where we are sure that the possibility exists that we can use colors. Not all places satisfy this requirement and the above code thereby technically runs to early and is slightly inefficient in that regard.
		// NOTE: That would require writing it multiple times though and the code wouldn't look as nice.
		// NOTE: Since this overhead is so incredibly small and only transpires one single time, there is essentially no cost, which is why I'm ok with not moving it. SIDE-NOTE: Yes, we could use a function for this, but that still produces less pretty code than the current situation.

		isErrorColored = true;
		forcedErrorColoring = true;
	}
	else {
	ANSIErrorSetupFailure:
		isErrorColored = false;
		forcedErrorColoring = false;
	}

	// NOTE: The reason we set the forcedOutputColoring as well as the isOutputColored flag above is because we set isOutputColored to forcedOutputColoring later in the code and we don't want that operation to mess up our coloring code.

	manageArgs(argc, argv);

	HistoryBuffer::init();				// Regardless of whether or not we actually plan to use HistoryBuffer and whether or not it's count is 0, there will always be one slot in it's array that we can use to cache the current line. This method is memory and processing power efficient because we don't have to copy or swap for history pushes.

	// NOTE: As much of the branching is done outside of the loops as possible so as to avoid checking data over and over even though it'll never change it's value.
	// The compiler is really good at doing this and technically would do it for me, but this way it's a safe bet and I can rest easy. Also, the main reason is that this way is more organized.
	// Trying to branch inside the loops and to condense everything down to one single loop with a bunch of conditionals inside gets ugly really fast. I prefer this layout more.
	if (isOutputColored) {					// If output is colored, activate colors before going into each loop and do the more complex matching algorithm
		if (flags::allLines) {
			if (flags::inverted) { return 0; }
			if (flags::only_line_nums) {
				LINE_WHILE_START
					if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { std::cout << color::red << lineCounter << color::reset << '\n'; lineCounter++; LINE_WHILE_CONTINUE; }
					std::cout << lineCounter << '\n'; lineCounter++;
				LINE_WHILE_END()
			}
			if (flags::lineNums) {						// NOTE: One would think that an improvement would be to snap all line numbers to the same column so as to avoid the text shifting to the right when line numbers go from 9 to 10 or from 99 to 100, but thats easier said than done, because we don't actually know how much room to leave in the column before reading the whole file.
				LINE_WHILE_START				// NOTE: Since we should be prepared to read incredibly long files, I'm going to leave the snapping out, since we can't really implement it without giving ourselves a maximum amount of line numbers we can traverse.
					if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { std::cout << color::red << lineCounter << color::reset << ' '; highlightMatches(); std::cout << CURRENT_LINE_ALIAS << '\n'; lineCounter++; LINE_WHILE_CONTINUE; }
					std::cout << lineCounter << ' ' << CURRENT_LINE_ALIAS << '\n'; lineCounter++;
				LINE_WHILE_END()
			}
			LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { highlightMatches(); } std::cout << CURRENT_LINE_ALIAS << '\n'; LINE_WHILE_END()
		}

		if (flags::context) {
			if (flags::only_line_nums) {
				if (flags::inverted) {
					LINE_WHILE_START
						if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
							HistoryBuffer::purgeAmountFilled();
							lineCounter++;
							for (size_t afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; lineCounter < afterLastLineOfPadding; ) {
								INNER_WINDOWS_SIGNAL_CHECK_START
									CURRENT_LINE_ALIAS.clear();
									INNER_INPUT_STREAM_READ_LINE
									if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { lineCounter++; afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; continue; }
									lineCounter++;
								INNER_WINDOWS_SIGNAL_CHECK_END
							}
							LINE_WHILE_CONTINUE;
						}
						size_t safestLineNum; if (HistoryBuffer::peekSafestLineNum(safestLineNum)) { std::cout << safestLineNum << '\n'; }
						HistoryBuffer::incrementAmountFilled();
						lineCounter++;
					LINE_WHILE_END(HistoryBuffer::lastPrintLineNums())
				}
				LINE_WHILE_START
					if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
						HistoryBuffer::printLineNums();
						std::cout << color::red << lineCounter << color::reset << '\n';
						lineCounter++;
						for (size_t afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; lineCounter < afterLastLineOfPadding; ) {			// SIDE-NOTE: Technically, for a lot of my use-cases, a do-while loop would be more efficient than a for loop since the initial check is garanteed to return true.
							INNER_WINDOWS_SIGNAL_CHECK_START																									// SIDE-NOTE: Even so, I like the way for loops look because you see the information for the loop at the top and not all the way at the bottom, plus, compiler optimizes.
								CURRENT_LINE_ALIAS.clear();
								INNER_INPUT_STREAM_READ_LINE
								if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
									std::cout << color::red << lineCounter << color::reset << '\n';
									lineCounter++;
									afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex;
									continue;
								}
								std::cout << lineCounter << '\n';
								lineCounter++;
							INNER_WINDOWS_SIGNAL_CHECK_END
						}
						LINE_WHILE_CONTINUE;
					}
					HistoryBuffer::incrementAmountFilled();
					lineCounter++;
				LINE_WHILE_END()
			}
			if (flags::lineNums) {
				if (flags::inverted) {
					LINE_WHILE_START
						if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
							HistoryBuffer::purgeWithAmountSet();
							lineCounter++;
							for (size_t afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; lineCounter < afterLastLineOfPadding; ) {
								INNER_WINDOWS_SIGNAL_CHECK_START
									CURRENT_LINE_ALIAS.clear();
									INNER_INPUT_STREAM_READ_LINE
									if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { lineCounter++; afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; continue; }
									lineCounter++;
								INNER_WINDOWS_SIGNAL_CHECK_END
							}
							LINE_WHILE_CONTINUE;
						}
						std::string safestLine;
						if (HistoryBuffer::peekSafestLine(safestLine)) {
							size_t safestLineNum; if (HistoryBuffer::peekSafestLineNum(safestLineNum)) { std::cout << safestLineNum << ' ' << safestLine << '\n'; }
						}
						HistoryBuffer::pushWithAmountInc();
						lineCounter++;
					LINE_WHILE_END(HistoryBuffer::printLinesWithLineNums())
				}
				LINE_WHILE_START
					if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
						HistoryBuffer::printLinesWithLineNums();
						std::cout << color::red << lineCounter << color::reset << ' '; highlightMatches(); std::cout << CURRENT_LINE_ALIAS << '\n';
						lineCounter++;
						for (size_t afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; lineCounter < afterLastLineOfPadding; ) {
							INNER_WINDOWS_SIGNAL_CHECK_START
								CURRENT_LINE_ALIAS.clear();
								INNER_INPUT_STREAM_READ_LINE
								if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
									std::cout << color::red << lineCounter << color::reset << ' '; highlightMatches(); std::cout << CURRENT_LINE_ALIAS << '\n';
									lineCounter++;
									afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex;
									continue;
								}
								std::cout << lineCounter << ' ' << CURRENT_LINE_ALIAS << '\n';
								lineCounter++;
							INNER_WINDOWS_SIGNAL_CHECK_END
						}
						LINE_WHILE_CONTINUE;
					}
					HistoryBuffer::push();
					lineCounter++;
				LINE_WHILE_END()
			}
			if (flags::inverted) {
				LINE_WHILE_START
					if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
						HistoryBuffer::purgeWithAmountSet();
						for (unsigned int padding = HistoryBuffer::buffer_lastIndex; padding > 0; ) {
							INNER_WINDOWS_SIGNAL_CHECK_START
								CURRENT_LINE_ALIAS.clear();
								INNER_INPUT_STREAM_READ_LINE
								if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { padding = HistoryBuffer::buffer_lastIndex; continue; }
								padding--;
							INNER_WINDOWS_SIGNAL_CHECK_END
						}
						LINE_WHILE_CONTINUE;
					}
					std::string safestLine; if (HistoryBuffer::peekSafestLine(safestLine)) { std::cout << safestLine << '\n'; }
					HistoryBuffer::pushWithAmountInc();
				LINE_WHILE_END(HistoryBuffer::print())
			}
			LINE_WHILE_START
				if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
					HistoryBuffer::print();
					highlightMatches(); std::cout << CURRENT_LINE_ALIAS << '\n';
					for (unsigned int padding = HistoryBuffer::buffer_lastIndex; padding > 0; ) {
						INNER_WINDOWS_SIGNAL_CHECK_START
							CURRENT_LINE_ALIAS.clear();
							INNER_INPUT_STREAM_READ_LINE
							if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
								highlightMatches(); std::cout << CURRENT_LINE_ALIAS << '\n';
								padding = HistoryBuffer::buffer_lastIndex;
								continue;
							}
							std::cout << CURRENT_LINE_ALIAS << '\n';
							padding--;
						INNER_WINDOWS_SIGNAL_CHECK_END
					}
					LINE_WHILE_CONTINUE;
				}
				HistoryBuffer::push();
			LINE_WHILE_END()
		}

		// SIDE-NOTE: Storing these command-line flags in a bit field and switching on it's value might have been a better way to do this in theory, because it's more efficient and might look better, but in practice, it might not have been the way to go.
		// It's not very scalable because you have to write out every single case (or use default, but that isn't applicable when you have complex relationships between cases and such). As soon as you have anywhere near something like 16 flags, your code bloat starts to become insane.
		// So I think the if statement approach is a good one, even though it's technically a very small bit less performant than the switch case approach.

		if (flags::inverted) {
			if (flags::only_line_nums) { LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { lineCounter++; LINE_WHILE_CONTINUE; } std::cout << lineCounter << '\n'; lineCounter++; LINE_WHILE_END() }
			if (flags::lineNums) { LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { lineCounter++; LINE_WHILE_CONTINUE; } std::cout << lineCounter << ' ' << CURRENT_LINE_ALIAS << '\n'; lineCounter++; LINE_WHILE_END() }
			LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { LINE_WHILE_CONTINUE } std::cout << CURRENT_LINE_ALIAS << '\n'; LINE_WHILE_END()
		}
		if (flags::only_line_nums) {
			if (forcedOutputColoring) { LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { std::cout << color::red << lineCounter << color::reset << '\n'; } lineCounter++; LINE_WHILE_END() }
			COLORED_RED_ONLY_LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { std::cout << lineCounter << '\n'; } lineCounter++; COLORED_RED_ONLY_LINE_WHILE_END()
		}
		if (flags::lineNums) { LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { std::cout << color::red << lineCounter << color::reset << ' '; highlightMatches(); std::cout << CURRENT_LINE_ALIAS << '\n'; } lineCounter++; LINE_WHILE_END() }
		LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { highlightMatches(); std::cout << CURRENT_LINE_ALIAS << '\n'; } LINE_WHILE_END()
	}

	if (flags::allLines) {
		if (flags::inverted) { return 0; }
		if (flags::only_line_nums) { MAIN_WHILE { INNER_INPUT_STREAM_DISCARD_LINE std::cout << lineCounter << '\n'; lineCounter++; } }					// NOTE: At first glance, it looks like InputStream and HistoryBuffer aren't being released here, but they are. This code is completely fine.
		if (flags::lineNums) { LINE_WHILE_START std::cout << lineCounter << ' ' << CURRENT_LINE_ALIAS << '\n'; lineCounter++; LINE_WHILE_END() }
		LINE_WHILE_START std::cout << CURRENT_LINE_ALIAS << '\n'; LINE_WHILE_END()
	}

	if (flags::context) {
		if (flags::only_line_nums) {
			if (flags::inverted) {
				LINE_WHILE_START
					if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
						HistoryBuffer::purgeAmountFilled();
						lineCounter++;
						for (size_t afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; lineCounter < afterLastLineOfPadding; ) {
							INNER_WINDOWS_SIGNAL_CHECK_START
								CURRENT_LINE_ALIAS.clear();
								INNER_INPUT_STREAM_READ_LINE
								if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { lineCounter++; afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; continue; }
								lineCounter++;
							INNER_WINDOWS_SIGNAL_CHECK_END
						}
						LINE_WHILE_CONTINUE;
					}
					size_t safestLineNum; if (HistoryBuffer::peekSafestLineNum(safestLineNum)) { std::cout << safestLineNum << '\n'; }
					HistoryBuffer::incrementAmountFilled();
					lineCounter++;
				LINE_WHILE_END(HistoryBuffer::lastPrintLineNums())
			}
			LINE_WHILE_START
				if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
					HistoryBuffer::printLineNums();
					std::cout << lineCounter << '\n';
					lineCounter++;
					for (size_t afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; lineCounter < afterLastLineOfPadding; ) {
						INNER_WINDOWS_SIGNAL_CHECK_START
							CURRENT_LINE_ALIAS.clear();
							INNER_INPUT_STREAM_READ_LINE
							std::cout << lineCounter << '\n';
							lineCounter++;
							if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; }
						INNER_WINDOWS_SIGNAL_CHECK_END
					}
					LINE_WHILE_CONTINUE;
				}
				HistoryBuffer::incrementAmountFilled();
				lineCounter++;
			LINE_WHILE_END()
		}
		if (flags::lineNums) {
			if (flags::inverted) {
				LINE_WHILE_START
					if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
						HistoryBuffer::purgeWithAmountSet();
						lineCounter++;
						for (size_t afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; lineCounter < afterLastLineOfPadding; ) {
							INNER_WINDOWS_SIGNAL_CHECK_START
								CURRENT_LINE_ALIAS.clear();
								INNER_INPUT_STREAM_READ_LINE
								if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { lineCounter++; afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; continue; }
								lineCounter++;
							INNER_WINDOWS_SIGNAL_CHECK_END
						}
						LINE_WHILE_CONTINUE;
					}
					std::string safestLine;
					if (HistoryBuffer::peekSafestLine(safestLine)) {
						size_t safestLineNum; if (HistoryBuffer::peekSafestLineNum(safestLineNum)) { std::cout << safestLineNum << ' ' << safestLine << '\n'; }
					}
					HistoryBuffer::pushWithAmountInc();
					lineCounter++;
				LINE_WHILE_END(HistoryBuffer::printLinesWithLineNums())
			}
			LINE_WHILE_START
				if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
					HistoryBuffer::printLinesWithLineNums();
					std::cout << lineCounter << ' ' << CURRENT_LINE_ALIAS << '\n';
					lineCounter++;
					for (size_t afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; lineCounter < afterLastLineOfPadding; ) {
						INNER_WINDOWS_SIGNAL_CHECK_START
							CURRENT_LINE_ALIAS.clear();
							INNER_INPUT_STREAM_READ_LINE
							std::cout << lineCounter << ' ' << CURRENT_LINE_ALIAS << '\n';
							lineCounter++;
							if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; }
						INNER_WINDOWS_SIGNAL_CHECK_END
					}
					LINE_WHILE_CONTINUE;
				}
				HistoryBuffer::push();
				lineCounter++;
			LINE_WHILE_END()
		}
		if (flags::inverted) {
			LINE_WHILE_START
				if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
					HistoryBuffer::purgeWithAmountSet();
					for (unsigned int padding = HistoryBuffer::buffer_lastIndex; padding > 0; ) {
						INNER_WINDOWS_SIGNAL_CHECK_START
							CURRENT_LINE_ALIAS.clear();
							INNER_INPUT_STREAM_READ_LINE
							if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { padding = HistoryBuffer::buffer_lastIndex; continue; }
							padding--;
						INNER_WINDOWS_SIGNAL_CHECK_END
					}
					LINE_WHILE_CONTINUE;
				}
				std::string safestLine; if (HistoryBuffer::peekSafestLine(safestLine)) { std::cout << safestLine << '\n'; }
				HistoryBuffer::pushWithAmountInc();
			LINE_WHILE_END(HistoryBuffer::print())
		}
		LINE_WHILE_START
			if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
				HistoryBuffer::print();
				std::cout << CURRENT_LINE_ALIAS << '\n';
				for (unsigned int padding = HistoryBuffer::buffer_lastIndex; padding > 0; ) {
					INNER_WINDOWS_SIGNAL_CHECK_START
						CURRENT_LINE_ALIAS.clear();
						INNER_INPUT_STREAM_READ_LINE
						if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
							std::cout << CURRENT_LINE_ALIAS << '\n';
							padding = HistoryBuffer::buffer_lastIndex;
							continue;
						}
						std::cout << CURRENT_LINE_ALIAS << '\n';
						padding--;
					INNER_WINDOWS_SIGNAL_CHECK_END
				}
				LINE_WHILE_CONTINUE;
			}
			HistoryBuffer::push();
		LINE_WHILE_END()
	}

	if (flags::inverted) {
		if (flags::only_line_nums) { LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { lineCounter++; LINE_WHILE_CONTINUE; } std::cout << lineCounter << '\n'; lineCounter++; LINE_WHILE_END() }
		if (flags::lineNums) { LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { lineCounter++; LINE_WHILE_CONTINUE; } std::cout << lineCounter << ' ' << CURRENT_LINE_ALIAS << '\n'; lineCounter++; LINE_WHILE_END() }
		LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { LINE_WHILE_CONTINUE; } std::cout << CURRENT_LINE_ALIAS << '\n'; LINE_WHILE_END()
	}
	if (flags::only_line_nums) { LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { std::cout << lineCounter << '\n'; } lineCounter++; LINE_WHILE_END() }
	if (flags::lineNums) { LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { std::cout << lineCounter << ' ' << CURRENT_LINE_ALIAS << '\n'; } lineCounter++; LINE_WHILE_END() }
	LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { std::cout << CURRENT_LINE_ALIAS << '\n'; } LINE_WHILE_END()
}

/*

NOTE:

The Windows implementation relies on EOF being sent on SIGINT, but still uses the shouldLoopRun variable in case things don't go as planned, in order to still be able to exit eventually.
The problem with this approach is that in pipes where the first program doesn't listen to SIGINT and doesn't signal EOF to this grep program, this grep program wants to exit, but doesn't get to until a line is sent to it's stdin.
This problem doesn't exist in the Linux version because we intercept SIGINT in grep through polling a sig fd, which makes it instant, regardless of if data is available on stdin or not.
In order to do this in the Windows version (where such nice things as signalfd don't exist to my knowledge), I would need to do a whole lot of research and potentially some weird stuff.
Honestly, I'm too lazy for that right now and we're talking about something that, in all likelyhood, will never become a problem.
If it does become a problem, I'll just use the Windows findstr for that case.
For now, I'm just going to leave it like this.

*/

/*

NOTE:

There seems to be a bug in std::regex when using keyphrase ".*". When just doing match over the whole line and not highlighting, everything is fine, but for some reason, it gets stuck on match 0 and just keeps looping over and over.
You could say that it has to happen this way because, while it is strange, that behaviour makes the most sense based on the code above, but why is everything fine for keyphrase ".*k" then. Shouldn't the same problem apply there?

*/
