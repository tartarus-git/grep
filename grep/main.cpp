// Memory usage.
#define INPUT_STREAM_BUFFER_MAX_SIZE 1024 * 1024																		// The maximum size to resize the stream buffer to. This prevents endless amounts of RAM from being used.
#define INPUT_STREAM_BUFFER_START_SIZE 256																				// The starting size for the stream buffer.
#define INPUT_STREAM_BUFFER_SIZE_STEP 256																				// How much more memory to reallocate with if the bounds of the previous memory were hit.

#define HISTORY_BUFFER_MAX_LINE_COUNT 63																				// Maximum num of lines storable in history buffer when using --context x flag. Note that the count of history buffer is HISTORY_BUFFER_MAX_LINE_COUNT + 1 because of circular buffer.

// TODO: Make absolutely sure that I'm not including too much.

#include <csignal>																										// Signalling and polling things.
#ifndef PLATFORM_WINDOWS
#include <sys/signalfd.h>
#include <poll.h>
#endif

#ifdef PLATFORM_WINDOWS
#define WIN32_LEAN_AND_MEAN																								// Include Windows.h to get access to the few winapi functions that we need, such as the ones for getting console input handle and setting ANSI escape code support.
#include <Windows.h>
#endif

#include <cstdlib>																										// Needed for realloc function.

#ifdef PLATFORM_WINDOWS
#include <io.h>																											// Needed for _isatty function.
#define isatty(x) _isatty(x)																							// Renaming _isatty to isatty so it's the same as the function call in Linux.
#else
#include <unistd.h>																										// Linux isatty function is in here as well as some other useful stuff for this program as well I think.
#endif

#include <chrono>																										// For access to time durations for use with sleep_for().
#include <thread>																										// For access to std::this_thread::sleep_for() and std::this_thread::yield().

#include <cstdio>																										// NOTE: Use "c___" headers instead of "____.h" headers whenever possible. The "c___" counterparts minimize global scope pollution by putting a lot of things in namespaces and replacing some #defines with functions. It's more "correct".
#include <iostream>
#include <string>
#include <regex>

#ifdef PLATFORM_WINDOWS																									// These #defines are already defined in one of the Linux-only headers, but for Windows, we need to explicitly do it.
#define STDIN_FILENO 0
#define STDOUT_FILENO 1
#endif

/*

NOTE: I've just learned about compiler intrinsics and SIMD and such and I'm going to write it here so I have a reference for later and don't forget:
So SIMD is often mentioned as a way to speed up computations and you should be aware of it so that you might use it in the future to speed up some of your algorithms.
IMPORTANT: A fair amount of SIMD instructions are already generated by the compiler when compiling normal code, because the compiler will optimize things that it can do better with SIMD. That means that you need not worry for a lot of calculations, because the optimizer has your back AFAIK.
SIMD stands for Single Instruction Multiple Data. It means that, rather than operating on one word or one unit of data per instruction, one instruction will alter a whole array (vector) of words or units in one go. This is awesome because it requires the same amount of time but can make your programs
a lot faster (potentially). That means, that for a lot of simple additions and multiplications and what not inside of functions, you're actually wasting processing power because you could be doing four at a time.
Obviously, that means that you should theoretically use SIMD everywhere, but that would be a major hassle and potentially screw up some of your cross platform-ness. For those simple optimizations, I would think it would be pretty safe to rely on the compiler to group and optimize certain calculations.
SIMD is super useful for stuff like going through arrays with loops. The practice of loop unrolling already exists to make this process more efficient (calculating four elements and then moving on to the next four for example), but this can be made even better by having those four elements be handled by a single SIMD
instruction.
IMPORTANT: If the heavy lifting inside of your algorithms is done using standard library functions, you can rest easy AFAIK, because they are most likely implemented as efficiently as possible and are tailored to your system. That means SIMD is most likely used to it's full potential in those functions.
There are different instructions sets that got added to CPU's over the years, each expanding the SIMD functionality of the CPU's. For example, SSE (Streaming SIMD Extentions) is one of those, it has different versions as well.
You can basically rely on the fact that CPU's are super backwards compatible and that if a SIMD instruction set was once implemented, it will still be there along with whatever new instruction sets have been added since.
IMPORTANT: SIMD is not cross platform technically, you have to specialize your code to use a specific SIMD instruction set, which depends on the architecture that you are using. In practice, this doesn't matter all too much because, if you choose an instruction set that is old enough (doesn't even have to be that old),
it'll be supported by all the CPU's that you would ever really want to run your code on.
To use a SIMD instruction set, you have to include the required header. This header will be filled with what are known as compiler intrinsics, which are, AFAIK, functions that are specific to the compiler and, in this case, translate directly into SIMD instructions.
There are different headers for different instruction sets, you have to google around to find the one you want to use. The recommended one for standard SIMD stuff is immintrin.h.
The header exists for both MSVC and gcc and includes all the other headers you would probably want, which means it includes basically all the other instruction sets. The header will be made available if the intrinsics are available for the system you are compiling for.
Since this header has so many different versions, it will always be available AFAIK, some intrinsics inside may not be available though because they might not be supported AFAIK.
The documentation for this stuff is lacking in my opinion, so researching is a slight pain, but it is very much worth it to implement SIMD instructions if you come across the right spot in code, because it could dramatically speed up your processing.

Heres an interesting way to look at things:
Normal CPU instructions --> super linear, theoretically not vectorized (they don't behave like SIMD instructions), although I'm not sure how many normal instructions make use of vectorization, it does seems to be the way CPU's are heading.
SIMD instructions --> useful, but relatively minimal vectorization (usually 4 or 8 words per instruction AFAIK)
GPU code with OpenCL for example --> A huge amount of computations at the same time, not because of instructions that manipulate multiple data, but because of the crazy amount of CPU cores.
The three types of programming can sort of be seen as in a heirarchy or a ladder or something. Why would you ever use SIMD over OpenCL? SIMD has so much less overhead than queueing kernels in OpenCL AFAIK. SIMD is super useful when you want to vectorize small amounts of things.
If you want to process a huge array in parallel, GPU computing is the way to go, instead of using SIMD.

Another concept that builds on SIMD: SWAR (SIMD Within A Register):
Very simple AFAIK. It is basically just more instructions, which also act like SIMD instructions, but they use data units that are smaller than normal for example (or registers that are larger than normal), to process multiple data within the one register.
Effectively does the same thing as SIMD, I'm not really sure why it warrants it's own acronym.

Beneifts of SWAR over SIMD: The benefits come only from the fact that, through sacrificing resolution of your values (moving from whole words to partial words), you can process more values in parallel AFAIK, which is faster.

*/

// ANSI escape code helpers.
#define ANSI_ESC_CODE_PREFIX "\033["
#define ANSI_ESC_CODE_SUFFIX "m"
#define ANSI_ESC_CODE_MIN_SIZE ((sizeof(ANSI_ESC_CODE_PREFIX) - 1) + (sizeof(ANSI_ESC_CODE_SUFFIX) - 1))

const char* helpText = "grep accepts text as input and outputs the lines from the input that have the specified keyphrase in them\n" \
					   "\n" \
					   "usage: grep [-calv] [--context <amount> || --only-line-nums || --color <auto|on|off>] <regex keyphrase>\n" \
					   "       grep <--help || --h>            -->            shows help text\n" \
					   "\n" \
					   "arguments:\n" \
							"\t-c                           -->         be case sensitive when matching\n" \
							"\t-a                           -->         print all lines from input but still color matches\n" \
							"\t-l                           -->         print line numbers\n" \
							"\t-v                           -->         invert output - print lines that would normally be omitted and omit lines that would normally be printed\n" \
							"\t--context <amount>           -->         print the specified amount of context (in lines) around each matched line\n" \
							"\t--only-line-nums             -->         print only the line numbers, not the actual lines\n" \
							"\t--color <auto|on|off>        -->         force a specific coloring behaviour, auto is default\n";

// Flag to keep track of whether we should color output or not.
bool isOutputColored;

// Output coloring.
namespace color {
	char* red = nullptr;										// NOTE: The nullptr is needed so that error reporting subroutines know if they need to allocate colors or if it has been done for them already.
	void unsafeInitRed() { red = new char[ANSI_ESC_CODE_MIN_SIZE + 2 + 1]; memcpy(red, ANSI_ESC_CODE_PREFIX "31" ANSI_ESC_CODE_SUFFIX, ANSI_ESC_CODE_MIN_SIZE + 2 + 1); }
	void unsafeInitPipedRed() { red = new char; *red = '\0'; }

	char* reset;
	void unsafeInitReset() { reset = new char[ANSI_ESC_CODE_MIN_SIZE + 1 + 1]; memcpy(reset, ANSI_ESC_CODE_PREFIX "0" ANSI_ESC_CODE_SUFFIX, ANSI_ESC_CODE_MIN_SIZE + 1 + 1); }
	void unsafeInitPipedReset() { reset = new char; *reset = '\0'; }

	void initErrorColoring() { if (isOutputColored) { unsafeInitRed(); unsafeInitReset(); return; } unsafeInitPipedRed(); unsafeInitPipedReset(); }

	void release() { delete[] color::red; delete[] color::reset; }
}

// TODO: Remove the whole format error thing and just write it in the string. No extra characters pretty much and you also reduce the number of function calls to the streaming operator of ostream.

// Output formatting.
namespace format {
	const char* const error = "ERROR: ";	// NOTE: const char* const instead of const char* doesn't always work. In the cases where you intend to change what the const char* pointer points to, const char* allows that while const char* const doesn't. In this case, const char* const is absolutely fine, but a lot of people still don't write it because personal preference and style.
}

#ifdef PLATFORM_WINDOWS																// Only needed on Windows because we signal for the main loop to stop in Linux via artifical EOF signal.
bool shouldLoopRun = true;
void signalHandler(int signum) { shouldLoopRun = false; }
#endif

// Collection of flags. These correspond to command-line flags you can set for the program.
namespace flags {
	bool caseSensitive = false;
	bool allLines = false;
	bool lineNums = false;
	bool inverted = false;
	bool context = false;
	bool only_line_nums = false;
}

// Keeps track of the current line so a variety of helper functions can do things with it.
size_t lineCounter = 1;

class HistoryBuffer {
	static unsigned int buffer_len;
	static unsigned int beginIndex;

public:
	static std::string* buffer;
	static unsigned int buffer_lastIndex;
	static unsigned int amountFilled;																	// This variable isn't always used, only for specific modes where keeping track of amount of filled slots is the most efficient way.
	static unsigned int index;

	static void incrementAmountFilled() { if (amountFilled != buffer_lastIndex) { amountFilled++; } }

	static void purgeAmountFilled() { amountFilled = 0; }

	static void init() {
		buffer_len = buffer_lastIndex + 1;
		buffer = new std::string[buffer_len];
	}

	static void push() {
		if (index == beginIndex - 1) {
			if (beginIndex == buffer_lastIndex) { index++; beginIndex = 0; return; }
			index++; beginIndex++; return;
		}
		if (index == buffer_lastIndex) { if (beginIndex == 0) { beginIndex = 1; } index = 0; return; }
		index++;
	}

	static void pushWithAmountInc() { push(); if (amountFilled != buffer_lastIndex) { amountFilled++; } }

	static void purge() { index = beginIndex; }

	static void purgeWithAmountSet() { purge(); purgeAmountFilled(); }

	static void print() { for ( ; beginIndex != index; beginIndex = (beginIndex == buffer_lastIndex ? 0 : beginIndex + 1)) { std::cout << buffer[beginIndex] << '\n'; } }			// NOTE: It is important to use '\n' instead of std::endl because std::endl puts a newline into the stream but also flushes it, which is a syscall, which is super slow. '\n' doesn't flush, so faster.

	// NOTE: We could store the amount filled and edit the variable with every call to push(), but I doubt that would be efficient since push is called so many more times than print is (at least normally).
	// Doing that would cause amountFilled to be added to over and over with little return on the investment. That's why we're just calculating amountFilled every time we need it, that way push() doesn't have to waste it's time incrementing anything.
	// NOTE: The exceptions to that rule are the peek functions. They're used for flags::inverted, where it's reasonable to cache amountFilled, so we do it there. Not for normal prints though.
	// NOTE: Another exception to that rule is flags::only_line_nums. There, the circular buffer isn't used and amountFilled is also the most efficient way of handling things. This is the case for printLineNums() and a couple functions at the top of the class.
	static unsigned int calculateAmountFilled() { return index > beginIndex ? index - beginIndex : buffer_len - beginIndex + index; }

	static void printLinesWithLineNums() {
		if (index == beginIndex) { return; }
		lineCounter -= calculateAmountFilled();
		std::cout << lineCounter << ' ' << buffer[beginIndex] << '\n';
		lineCounter++;
		beginIndex = (beginIndex == buffer_lastIndex ? 0 : beginIndex + 1);
		for ( ; beginIndex != index; beginIndex = (beginIndex == buffer_lastIndex ? 0 : beginIndex + 1), lineCounter++) { std::cout << lineCounter << ' ' << buffer[beginIndex] << '\n'; }
	}

	static void lastPrintLineNums() { for (size_t historyLine = lineCounter - amountFilled; historyLine < lineCounter; historyLine++) { std::cout << historyLine << '\n'; } }
	static void printLineNums() { lastPrintLineNums(); purgeAmountFilled(); }

	static bool peekSafestLine(std::string& safestLine) { if (amountFilled == buffer_lastIndex) { safestLine = buffer[beginIndex]; return true; } return false; }

	static bool peekSafestLineNum(size_t& safestNum) { if (amountFilled == buffer_lastIndex) { safestNum = lineCounter - buffer_lastIndex; return true; } return false; }

	static void release() { delete[] buffer; }
};

std::string* HistoryBuffer::buffer;
unsigned int HistoryBuffer::buffer_len;
unsigned int HistoryBuffer::index = 0;
unsigned int HistoryBuffer::beginIndex = 0;
unsigned int HistoryBuffer::buffer_lastIndex;
unsigned int HistoryBuffer::amountFilled = 0;

// Parse a single flag group. A flag group is made out of a bunch of single letter flags.
void parseFlagGroup(char* arg) {
	for (int i = 0; ; i++) {
		switch (arg[i]) {
		case 'c': flags::caseSensitive = true; break;
		case 'a': flags::allLines = true; break;
		case 'l': flags::lineNums = true; break;
		case 'v': flags::inverted = true; break;
		case '\0': return;
		default:
			color::initErrorColoring();
			std::cout << color::red << format::error << "one or more flag arguments are invalid" << color::reset << '\n';				// TODO: If it weren't for that windows C++ runtime thing where it puts another newline at the end, I would integrate the \n directly into the string. Is that still possible somehow on windows? Do we have to move away from ANSI escape codes for colors.
			// TODO: Actually, it doesn't seem to be the runtime, it's pesky powershell adding an extra newline to it when it writes it to files using redirection, Out-File or Set-Content, find a way to get around that.
			color::release();
			exit(EXIT_SUCCESS);
		}
	}
}

// Adds a character to the end of an unsigned integer.
bool addToUInt(unsigned int& value, char character) {
	if (character < '0' || character > '9' ) { return false; }
	value = value * 10 + (character - '0');
	return true;
}

unsigned int parseUInt(char* string) {
	unsigned int result = 0;
	if (string[0] != '\0') {
		if (addToUInt(result, string[0])) {
			for (int i = 1; ; i++) {
				if (addToUInt(result, string[i])) { continue; }
				if (string[i] == '\0' && result <= HISTORY_BUFFER_MAX_LINE_COUNT) { return result; }
				break;
			}
		}
	}
	color::initErrorColoring();
	std::cout << color::red << format::error << "invalid value for --context flag" << color::reset << '\n';
	color::release();
	exit(EXIT_SUCCESS);
}

void showHelp() { std::cout << helpText; }				// NOTE: I have previously only shown help when output is connected to TTY, so as not to pollute stdout when piping. Back then, help was shown sometimes when it wasn't requested, which made it prudent to include that feature. Now, you have to explicitly ask for help, making this TTY branching unnecessary.

bool forcedOutputColoring;					// NOTE: GARANTEE: If something goes wrong while parsing the cmdline args and an error message is necessary, the error message will always be printed with the default coloring (based on TTY/piped mode).

// Parse flags at the argument level. Calls parseFlagGroup if it encounters flag groups and handles word flags (those with -- in front) separately.
unsigned int parseFlags(int argc, char** argv) {																// NOTE: If you write --context twice or --color twice (or any additional flags that we may add), the value supplied to the rightmost instance will be the value that is used. Does not throw an error.
	for (int i = 1; i < argc; i++) {
		const char* arg = argv[i];
		if (arg[0] == '-') {
			if (arg[1] == '-') {
				const char* flagTextStart = arg + 2;
				if (*flagTextStart == '\0') { continue; }
				if (!strcmp(flagTextStart, "context")) {
					i++;
					if (i == argc) {
						color::initErrorColoring();
						std::cout << color::red << format::error << "the --context flag was not supplied with a value" << color::reset << '\n';
						color::release();
						exit(EXIT_SUCCESS);
					}
					HistoryBuffer::buffer_lastIndex = parseUInt(argv[i]);
					if (HistoryBuffer::buffer_lastIndex == 0) { continue; }															// Context value 0 is the same as no context, so don't bother setting context up.
					flags::context = true;
					continue;
				}
				if (!strcmp(flagTextStart, "only-line-nums")) { flags::only_line_nums = true; continue; }
				if (!strcmp(flagTextStart, "color")) {
					i++;
					if (i == argc) {
						color::initErrorColoring();
						std::cout << color::red << format::error << "the --color flag was not supplied with a value" << color::reset << '\n';
						color::release();
						exit(EXIT_SUCCESS);
					}
					if (!strcmp(argv[i], "on")) { forcedOutputColoring = true; continue; }
					if (!strcmp(argv[i], "off")) { forcedOutputColoring = false; continue; }
					if (!strcmp(argv[i], "auto")) { forcedOutputColoring = isOutputColored; continue; }
					color::initErrorColoring();
					std::cout << color::red << format::error << "invalid value for --color flag" << color::reset << '\n';
					color::release();
					exit(EXIT_SUCCESS);
				}
				if (!strcmp(flagTextStart, "help")) { showHelp(); exit(EXIT_SUCCESS); }
				if (!strcmp(flagTextStart, "h")) { showHelp(); exit(EXIT_SUCCESS); }
				color::initErrorColoring();
				std::cout << color::red << format::error << "one or more flag arguments are invalid" << color::reset << '\n';
				color::release();
				exit(EXIT_SUCCESS);
			}
			parseFlagGroup(argv[i] + 1);
			continue;
		}
		return i;																									// Return index of first arg that isn't flag arg. Helps calling code parse args.
	}
	return argc;																									// No non-flag argument was found. Return argc because it works nicely with calling code.
}

std::regex keyphraseRegex;

// Arg management function. Handles some argument parsing but pushes flag parsing to parseFlags.
void manageArgs(int argc, char** argv) {
	unsigned int keyphraseArgIndex = parseFlags(argc, argv);														// Parse flags before doing anything else.
	switch (argc - keyphraseArgIndex) {
	case 0:
		color::initErrorColoring();
		std::cout << color::red << format::error << "too few arguments" << color::reset << '\n';
		color::release();
		exit(EXIT_SUCCESS);
	case 1:
	{
		bool previousOutputColoring = isOutputColored;
		isOutputColored = forcedOutputColoring;																		// If everything went great with parsing the cmdline args, finally set output coloring to what the user wants it to be. It is necessary to do this here because of the garantee that we wrote above.
		forcedOutputColoring = previousOutputColoring;						// This is some dirty code to repurpose the forcedOutputColoring variable as the true indicator of if we are connected to TTY or not, you should probably fix this and make a better system. TODO
		{																											// Unnamed namespace because we can't create variables inside switch cases otherwise.
			std::regex_constants::syntax_option_type regexFlags = std::regex_constants::grep | std::regex_constants::nosubs | std::regex_constants::optimize;
			if (!flags::caseSensitive) { regexFlags |= std::regex_constants::icase; }
			try { keyphraseRegex = std::regex(argv[keyphraseArgIndex], regexFlags); }								// Parse regex keyphrase.
			catch (const std::regex_error& err) {																	// Catch any errors relating to keyphrase regex syntax and report them.
				color::initErrorColoring();
				std::cout << color::red << format::error << "regex error: " << err.what() << color::reset << '\n';
				color::release();
				exit(EXIT_SUCCESS);
			}
		}
	}					// TODO: Clean up these unnamed namespaces. Think about it, is there a reason to have two here?
		return;
	default:																										// If more than 1 non-flag argument exists (includes flags after first non-flag arg), throw error.
		color::initErrorColoring();
		std::cout << color::red << format::error << "too many arguments" << color::reset << '\n';
		color::release();
		exit(EXIT_SUCCESS);
	}
}

// TODO: Go through all your usages of '\n' with std::cout and make sure you can't make any of them simpler by integrating the newline into the string or something.

// Handles input in a buffered way.
class InputStream {
#ifdef PLATFORM_WINDOWS
public:
	static void init() { std::cin.sync_with_stdio(false); }															// Unsynchronize C++ input buffer with C input buffer. This often makes things faster because implementors often don't bother buffering input until this is set to false (where they can then safely buffer input).
#else
	static pollfd fds[2];																							// File descriptors to poll. One for stdin and one for a signal fd.
	static sigset_t sigmask;																						// Signals to handle with poll.

	static char* buffer;
	static size_t bufferSize;

	static ssize_t bytesRead;																						// Position of read head in buffer.
	static ssize_t bytesReceived;																					// Position of write head in buffer.

public:
	static void init() {
		buffer = new char[bufferSize];																				// Initialize buffer with the starting amount of RAM space.
		
		// Add SIGINT and SIGTERM to set of tracked signals.
		if (sigemptyset(&sigmask) == -1) { goto errorBranch; }
		if (sigaddset(&sigmask, SIGINT) == -1) { goto errorBranch; }
		if (sigaddset(&sigmask, SIGTERM) == -1) { goto errorBranch; }

		// Block the set of tracked signals from being handled by default by thread because obviously we're handling them.
		if (sigprocmask(SIG_BLOCK, &sigmask, nullptr) == -1) { goto errorBranch; }

		// Create new file descriptor. Makes a read available when one of the tracked signals is caught.
		{
			int sigfd = signalfd(-1, &sigmask, 0);
			fds[1].fd = sigfd;																						// Add sigfd to list of to be polled file descriptors, so we can be notified if we get a signal from poll. It doesn't matter if it's -1 because on failure we set it to that anyway.
			return;
		}

errorBranch:	fds[1].fd = -1;																						// Tell poll to ignore the now unused entry in fds because some error prevented us from setting it up correctly.
	}

	// NOTE: I think we probably could have just used the standard input buffering mechanisms (while retaining the ability to adjust buffer size) instead of building our own.
	// NOTE: That would probably be faster since the standard is optimized for each platform. I'm too proud of my mechanism to remove it right now, so I'm leaving it in for the forseeable future.
	// NOTE: Plus, I haven't done any benchmarks. Maybe this is faster than the standard because the standard might do a bunch of safety checks and unnecessary stuff.

	static bool refillBuffer() {
		// When no more data left in buffer, try get more.
		if (poll(fds, 2, -1) == -1) {																				// Block until we either get some input on stdin or get either a SIGINT or a SIGTERM.
			if (!color::red) { color::initErrorColoring(); }
			std::cout << color::red << format::error << "failed to poll stdin, SIGINT and SIGTERM" << color::reset << '\n';
			return false;
		}

		if (fds[1].revents) { return false; }																		// Signal EOF if we caught a signal.

		bytesReceived = read(STDIN_FILENO, buffer, bufferSize);														// Read as much as we can fit into the buffer.

		if (bytesReceived == 0) { return false; }																	// In case of actual EOF, signal EOF.
		if (bytesReceived == -1) {																					// In case of error, log and signal EOF.
			if (!color::red) { color::initErrorColoring(); }
			std::cout << color::red << format::error << "failed to read from stdin" << color::reset << '\n';
			return false;

		}
		bytesRead = 0;																								// If new data is read, the read head needs to be reset to the beginning of the buffer.

		// TODO: The below comparison gives warnings on gcc. Makes sense, can we stop comparing two different types here?
		if (bytesReceived == bufferSize) {																			// Make buffer bigger if it is filled with one read syscall. This minimizes amount of syscalls we have to do. Buffer doesn't have the ability to get smaller again, doesn't need to.
			size_t newBufferSize = bufferSize + INPUT_STREAM_BUFFER_SIZE_STEP;
			char* newBuffer = (char*)realloc(buffer, newBufferSize);
			if (newBuffer) { buffer = newBuffer; bufferSize = newBufferSize; }
		}			// TODO: Actually use HISTORY_BUFFER_MAX_SIZE here. Also add parenthesese around the define because thats safer. This is super important, integral stuff that you've just forgotten, get it done.

		return true;
	}
#endif

	static bool readLine(std::string& line) {																		// Returns true on success. Returns false on EOF or error in Windows. Returns false on EOF or SIGINT or SIGTERM or error on Linux.
#ifdef PLATFORM_WINDOWS
		if (std::getline(std::cin, line)) { return true; }															// Get line. Technically, eofbit gets set if EOF terminates the line, but we don't worry about that because in that case we have to return true as well.
		// NOTE: Technically, one could put the below line above std::getline, but that would do an unnecessary branch for every readLine in the file. This way, the branch is only tested when it has to be, which induces small overhead at EOF but saves a bunch of overhead in the loops.
		// NOTE: More importantly, that only works if you assume that the last line of the file ends with EOF, but it might end in newline, in which case this is the better way to do it because it doesn't print an extra line at the bottom of the output.
		if (std::cin.eof()) { return false; }																		// If getline fails because we're trying to read at the EOF position (in which case eofbit will be set), return false without doing error reporting.
		if (!color::red) { color::initErrorColoring(); }															// Otherwise, some error occurred and we need to report it and return false.
		std::cout << color::red << format::error << "failed to read from stdin" << color::reset << '\n';
		return false;

#else
		while (true) {
			for (; bytesRead < bytesReceived; bytesRead++) {														// Read all the data in the buffer.
				if (buffer[bytesRead] == '\n') { bytesRead += 1; return true; }										// Stop when we encounter the end of the current line.
				line += buffer[bytesRead];
			}
			if (refillBuffer()) { continue; }																		// If we never encounter the end of the line in the current buffer, fetch more data.
			return false;																							// If something went wrong while refilling buffer, return false.
		}
#endif
	}

	static bool discardLine() {																						// Reads the next line but doesn't store it anywhere since we're only reading it to advance the read position. Returns true on success. Returns false on EOF or error in Windows. Returns false on EOF, SIGINT, SIGTERM or error on Linux.
#ifdef PLATFORM_WINDOWS
		char character;
		while (true) {																								// Not going to check for shouldLoopRun here because interrupting inside of a line isn't something that readLine offers either and because console is line-buffered anyway, so it wouldn't actually enable signalling while input is pending.
			character = std::cin.get();																				// Processing characters once they've been submitted by user is super fast, so the check would be pretty much unnecessary unless the lines are super super super long, which doesn't happen often.
			if (character == EOF) { return false; }																	// Even if the lines are long, all you'll have to do is press Ctrl+C and wait for the line to be over for grep to quit. This is all so unlikely, that I'm not going to waste a branch checking for it.
			if (std::cin.fail()) {
				if (!color::red) { color::initErrorColoring(); }
				std::cout << color::red << format::error << "failed to read from stdin" << color::reset << '\n';
				return false;
			}
			if (character == '\n') { return true; }
		}
#else
		while (true) {
			for ( ; bytesRead < bytesReceived; bytesRead++) { if (buffer[bytesRead] == '\n') { bytesRead += 1; return true; } }						// Read all the data in current buffer and exit as soon as we've discarded an entire line.
			if (refillBuffer()) { continue; }
			return false;
		}
#endif
	}

#ifndef PLATFORM_WINDOWS
	static void release() { delete[] buffer; }
#endif
};

// SUPER IMPORTANT TODO: Why are we not using the same buffering mechanism for windows as for Linux? Something to do with EOF's, but I don't think we understand all the stuff properly when we built this. The whole InputStream class could be improved. Do that.

#ifndef PLATFORM_WINDOWS																							// Static members variables only need to be initialized in Linux because we don't have any in Windows.
pollfd InputStream::fds[] = { STDIN_FILENO, POLLIN, 0, 0, POLLIN, 0 };												// Parts of this data get changed later in runtime.
sigset_t InputStream::sigmask;

char* InputStream::buffer;
size_t InputStream::bufferSize = INPUT_STREAM_BUFFER_START_SIZE;

ssize_t InputStream::bytesRead = 0;
ssize_t InputStream::bytesReceived = 0;
#endif

std::smatch matchData;

#define CURRENT_LINE_ALIAS HistoryBuffer::buffer[HistoryBuffer::index]

void highlightMatches() {																							// I assume this will be inlined. Probably not in debug mode, but almost definitely in release mode.
	do {
		ptrdiff_t matchPosition = matchData.position();
		std::cout.write(CURRENT_LINE_ALIAS.c_str(), matchPosition);
		std::cout << color::red;
		std::cout.write(CURRENT_LINE_ALIAS.c_str() + matchPosition, matchData.length());
		std::cout << color::reset;
		CURRENT_LINE_ALIAS = matchData.suffix();
	} while (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex));
}

// A couple of #defines to help reduce code bloat in the coming sections of the program.

#ifdef PLATFORM_WINDOWS
#define MAIN_WHILE InputStream::init(); while (shouldLoopRun)
#else
#define MAIN_WHILE InputStream::init(); while (true)
#endif


#define LINE_WHILE_START MAIN_WHILE { if (!InputStream::readLine(CURRENT_LINE_ALIAS)) { break; }
#ifdef PLATFORM_WINDOWS
#define LINE_WHILE_END(cleanupCode) } cleanupCode; HistoryBuffer::release(); return 0;								// NOTE: As per the standard, you can use function-style macros while leaving one or more or all of the parameters blank. They just won't be filled with anything and you'll have empty spots, which is exactly the behaviour we want here, so everythings fine.
#else
#define LINE_WHILE_END(cleanupCode) CURRENT_LINE_ALIAS.clear(); } cleanupCode; InputStream::release(); HistoryBuffer::release(); return 0;
#endif

#define COLORED_LINE_WHILE_START color::unsafeInitRed(); color::unsafeInitReset(); LINE_WHILE_START
#define COLORED_LINE_WHILE_END(cleanupCode) LINE_WHILE_END(cleanupCode; color::release())							// IMPORTANT: The only reason this is acceptable is because releasing HistoryBuffer and InputStream doesn't rely on color data because those release functions don't ever emit error messages. If it were different, this wouldn't be ok.
#define COLORED_RED_ONLY_LINE_WHILE_START color::unsafeInitRed(); color::unsafeInitReset(); std::cout << color::red; LINE_WHILE_START
#define COLORED_RED_ONLY_LINE_WHILE_END LINE_WHILE_END(std::cout << color::reset; color::release())					// IMPORTANT: This has the same deal as the commented line above.

#ifdef PLATFORM_WINDOWS
#define LINE_WHILE_CONTINUE continue;
#else
#define LINE_WHILE_CONTINUE CURRENT_LINE_ALIAS.clear(); continue;
#endif

#ifdef PLATFORM_WINDOWS
#define INNER_WINDOWS_SIGNAL_CHECK_START if (shouldLoopRun) {
#define INNER_WINDOWS_SIGNAL_CHECK_END(cleanupCode) } else { HistoryBuffer::release(); cleanupCode; return 0; }
#else
#define INNER_WINDOWS_SIGNAL_CHECK_START
#define INNER_WINDOWS_SIGNAL_CHECK_END(cleanupCode)
#endif

#ifdef PLATFORM_WINDOWS
#define INNER_INPUT_STREAM_READ_LINE(cleanupCode) if (!InputStream::readLine(CURRENT_LINE_ALIAS)) { HistoryBuffer::release(); cleanupCode; return 0; }
#define INNER_INPUT_STREAM_DISCARD_LINE(cleanupCode) if (!InputStream::discardLine()) { HistoryBuffer::release(); cleanupCode; return 0; }
#else
#define INNER_INPUT_STREAM_READ_LINE(cleanupCode) if (!InputStream::readLine(CURRENT_LINE_ALIAS)) { InputStream::release(); HistoryBuffer::release(); cleanupCode; return 0; }
#define INNER_INPUT_STREAM_DISCARD_LINE(cleanupCode) if (!InputStream::discardLine()) { InputStream::release(); HistoryBuffer::release(); cleanupCode; return 0; }
#endif

// NOTE: I'm not going to put any error handling on allocation fails because that shouldn't actually happen unless there is something wrong with the OS. If it does happen, an abort will be triggered and my program will quit, leaving the OS to clean up all of it's resources, which isn't good practice, but like I said, this shouldn't happen and putting in error handling
// NOTE: would be kind of awkward in some places. It would even force me to use exceptions as far as I can see (at the copying of one std::string into another), which I don't want to do.
// NOTE: There is one place where a large enough file would cause memory issues (std::string copying in HistoryBuffer), but I just assume that the user won't put in a huge huge huge file consisting of only one line into a grep program, what would be the use? If he does, then it's his fault and we'll just let the OS clean up, I don't really have a problem with that in that case.
// NOTE: Plus, like I said, it lets me avoid exception handling.

// TODO: Learn about SFINAE and std::enable_if.

// Program entry point
int main(int argc, char** argv) {
	std::cout.sync_with_stdio(false);		// Unsynchronize C++ output buffer with C output buffer. Normally set to true to avoid output getting mixed around when mixing C++ and C function calls in source code. Setting to false yields performance improvements for same reason as doing this for input buffers above.
											// IMPORTANT: As a result of doing this unsync stuff, we have to choose either C or C++ style and stick with it for the whole program. It is still possible to use C-style input and C++-style output at same time, the limitation only applies within the boundaries of input and output.
#ifdef PLATFORM_WINDOWS
	signal(SIGINT, signalHandler);			// Handling error here doesn't do any good because program should continue to operate regardless.
	signal(SIGTERM, signalHandler);			// Reacting to errors here might poison stdout for programs on other ends of pipes, so just leave this be.
#endif

	// Only enable colors if stdout is a TTY to make reading piped output easier for other programs.
	if (isatty(STDOUT_FILENO)) {
#ifdef PLATFORM_WINDOWS						// On windows, you have to set up virtual terminal processing explicitly and it for some reason disables piping. That's why this group is here.
		HANDLE consoleOutputHandle = GetStdHandle(STD_OUTPUT_HANDLE);
		if (!consoleOutputHandle || consoleOutputHandle == INVALID_HANDLE_VALUE) { return EXIT_FAILURE; }				// NOTE: Presumably, if this fails, then outputting to stdout probably will fail too, so why bother signalling error. Return EXIT_FAILURE instead. Since we don't return that anywhere else, it should actually be a good indicator of what happened.
		DWORD mode;
		if (!GetConsoleMode(consoleOutputHandle, &mode)) { return EXIT_FAILURE; }										// NOTE: Same deal as above AFAIK. Plus, these functions shouldn't really ever fail, so preparing an error output feels kind of weird. We use the error outputs for things that the user did wrong, so that might be why I have a problem with outputting on OS error.
		if (!SetConsoleMode(consoleOutputHandle, mode | ENABLE_VIRTUAL_TERMINAL_PROCESSING)) { return EXIT_FAILURE; }	// NOTE: If these calls fail, something about the OS is off and you should fix that before running the program again, but in normal operation, these should basically never fail. I don't see it as our duty to handle every possible, esoteric error.
#endif

		// TODO: If some part of the above isn't successful, just run the program as if it weren't connected to a tty, thats the best behaviour.

		// NOTE: Technically, it would be more efficient to place the above virtual terminal processing code in a place where we know for sure whether or not we are going to be using colors. That would require writing it multiple times though and the code wouldn't look as nice.
		// NOTE: Since this overhead is so incredibly small and only transpires one single time, there is essentially no cost, which is why I'm ok with not moving it. SIDE-NOTE: Yes, we could use a function for this, but that still produces less pretty code than the current situation.
		// TODO: The above notes don't make sense I believe, read them again and then delete them if they're not good.

		isOutputColored = true;
		forcedOutputColoring = true;
	}
	else { isOutputColored = false; forcedOutputColoring = false; }

	// NOTE: The reason we set the forcedOutputColoring as well as the isOutputColored flag above is because we set isOutputColored to forcedOutputColoring later in the code and we don't want that operation to mess up our coloring code.

	manageArgs(argc, argv);

	HistoryBuffer::init();				// Regardless of whether or not we actually plan to use HistoryBuffer and whether or not it's count is 0, there will always be one slot in it's array that we can use to cache the current line. This method is memory and processing power efficient because we don't have to copy or swap for history pushes.

	// NOTE: As much of the branching is done outside of the loops as possible so as to avoid checking data over and over even though it'll never change it's value.
	// The compiler is really good at doing this and technically would do it for me, but this way it's a safe bet and I can rest easy. Also, the main reason is that this way is more organized.
	// Trying to branch inside the loops and to condense everything down to one single loop with a bunch of conditionals inside gets ugly really fast. I prefer this layout more.
	if (isOutputColored) {					// If output is colored, activate colors before going into each loop and do the more complex matching algorithm
		if (flags::allLines) {
			if (flags::inverted) { return 0; }
			if (flags::only_line_nums) {
				COLORED_LINE_WHILE_START
					if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { std::cout << color::red << lineCounter << color::reset << '\n'; lineCounter++; LINE_WHILE_CONTINUE; }
					std::cout << lineCounter << '\n'; lineCounter++;
				COLORED_LINE_WHILE_END()
			}
			if (flags::lineNums) {						// NOTE: One would think that an improvement would be to snap all line numbers to the same column so as to avoid the text shifting to the right when line numbers go from 9 to 10 or from 99 to 100, but thats easier said than done, because we don't actually know how much room to leave in the column before reading the whole file.
				COLORED_LINE_WHILE_START				// NOTE: Since we should be prepared to read incredibly long files, I'm going to leave the snapping out, since we can't really implement it without giving ourselves a maximum amount of line numbers we can traverse.
					if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { std::cout << color::red << lineCounter << color::reset << ' '; highlightMatches(); std::cout << CURRENT_LINE_ALIAS << '\n'; lineCounter++; LINE_WHILE_CONTINUE; }
					std::cout << lineCounter << ' ' << CURRENT_LINE_ALIAS << '\n'; lineCounter++;
				COLORED_LINE_WHILE_END()
			}
			COLORED_LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { highlightMatches(); } std::cout << CURRENT_LINE_ALIAS << '\n'; COLORED_LINE_WHILE_END()
		}

		if (flags::context) {
			if (flags::only_line_nums) {
				if (flags::inverted) {
					LINE_WHILE_START
						if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
							HistoryBuffer::purgeAmountFilled();
							lineCounter++;
							for (size_t afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; lineCounter < afterLastLineOfPadding; ) {
								INNER_WINDOWS_SIGNAL_CHECK_START
									CURRENT_LINE_ALIAS.clear();
									INNER_INPUT_STREAM_READ_LINE()
									if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { lineCounter++; afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; continue; }
									lineCounter++;
								INNER_WINDOWS_SIGNAL_CHECK_END()
							}
							LINE_WHILE_CONTINUE;
						}
						size_t safestLineNum; if (HistoryBuffer::peekSafestLineNum(safestLineNum)) { std::cout << safestLineNum << '\n'; }
						HistoryBuffer::incrementAmountFilled();
						lineCounter++;
					LINE_WHILE_END(HistoryBuffer::lastPrintLineNums())
				}
				COLORED_LINE_WHILE_START
					if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
						HistoryBuffer::printLineNums();
						std::cout << color::red << lineCounter << color::reset << '\n';
						lineCounter++;
						for (size_t afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; lineCounter < afterLastLineOfPadding; ) {			// SIDE-NOTE: Technically, for a lot of my use-cases, a do-while loop would be more efficient than a for loop since the initial check is garanteed to return true.
							INNER_WINDOWS_SIGNAL_CHECK_START																									// SIDE-NOTE: Even so, I like the way for loops look because you see the information for the loop at the top and not all the way at the bottom, plus, compiler optimizes.
								CURRENT_LINE_ALIAS.clear();
								INNER_INPUT_STREAM_READ_LINE(color::release())
								if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
									std::cout << color::red << lineCounter << color::reset << '\n';
									lineCounter++;
									afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex;
									continue;
								}
								std::cout << lineCounter << '\n';
								lineCounter++;
							INNER_WINDOWS_SIGNAL_CHECK_END(color::release())
						}
						LINE_WHILE_CONTINUE;
					}
					HistoryBuffer::incrementAmountFilled();
					lineCounter++;
				COLORED_LINE_WHILE_END()
			}
			if (flags::lineNums) {
				if (flags::inverted) {
					LINE_WHILE_START
						if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
							HistoryBuffer::purgeWithAmountSet();
							lineCounter++;
							for (size_t afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; lineCounter < afterLastLineOfPadding; ) {
								INNER_WINDOWS_SIGNAL_CHECK_START
									CURRENT_LINE_ALIAS.clear();
									INNER_INPUT_STREAM_READ_LINE()
									if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { lineCounter++; afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; continue; }
									lineCounter++;
								INNER_WINDOWS_SIGNAL_CHECK_END()
							}
							LINE_WHILE_CONTINUE;
						}
						std::string safestLine;
						if (HistoryBuffer::peekSafestLine(safestLine)) {
							size_t safestLineNum; if (HistoryBuffer::peekSafestLineNum(safestLineNum)) { std::cout << safestLineNum << ' ' << safestLine << '\n'; }
						}
						HistoryBuffer::pushWithAmountInc();
						lineCounter++;
					LINE_WHILE_END(HistoryBuffer::printLinesWithLineNums())
				}
				COLORED_LINE_WHILE_START
					if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
						HistoryBuffer::printLinesWithLineNums();
						std::cout << color::red << lineCounter << color::reset << ' '; highlightMatches(); std::cout << CURRENT_LINE_ALIAS << '\n';
						lineCounter++;
						for (size_t afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; lineCounter < afterLastLineOfPadding; ) {
							INNER_WINDOWS_SIGNAL_CHECK_START
								CURRENT_LINE_ALIAS.clear();
								INNER_INPUT_STREAM_READ_LINE(color::release())
								if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
									std::cout << color::red << lineCounter << color::reset << ' '; highlightMatches(); std::cout << CURRENT_LINE_ALIAS << '\n';
									lineCounter++;
									afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex;
									continue;
								}
								std::cout << lineCounter << ' ' << CURRENT_LINE_ALIAS << '\n';
								lineCounter++;
							INNER_WINDOWS_SIGNAL_CHECK_END(color::release())
						}
						LINE_WHILE_CONTINUE;
					}
					HistoryBuffer::push();
					lineCounter++;
				COLORED_LINE_WHILE_END()
			}
			if (flags::inverted) {
				LINE_WHILE_START
					if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
						HistoryBuffer::purgeWithAmountSet();
						for (unsigned int padding = HistoryBuffer::buffer_lastIndex; padding > 0; ) {
							INNER_WINDOWS_SIGNAL_CHECK_START
								CURRENT_LINE_ALIAS.clear();
								INNER_INPUT_STREAM_READ_LINE()
								if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { padding = HistoryBuffer::buffer_lastIndex; continue; }
								padding--;
							INNER_WINDOWS_SIGNAL_CHECK_END()
						}
						LINE_WHILE_CONTINUE;
					}
					std::string safestLine; if (HistoryBuffer::peekSafestLine(safestLine)) { std::cout << safestLine << '\n'; }
					HistoryBuffer::pushWithAmountInc();
				LINE_WHILE_END(HistoryBuffer::print())
			}
			COLORED_LINE_WHILE_START
				if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
					HistoryBuffer::print();
					highlightMatches(); std::cout << CURRENT_LINE_ALIAS << '\n';
					for (unsigned int padding = HistoryBuffer::buffer_lastIndex; padding > 0; ) {
						INNER_WINDOWS_SIGNAL_CHECK_START
							CURRENT_LINE_ALIAS.clear();
							INNER_INPUT_STREAM_READ_LINE(color::release())
							if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
								highlightMatches(); std::cout << CURRENT_LINE_ALIAS << '\n';
								padding = HistoryBuffer::buffer_lastIndex;
								continue;
							}
							std::cout << CURRENT_LINE_ALIAS << '\n';
							padding--;
						INNER_WINDOWS_SIGNAL_CHECK_END(color::release())
					}
					LINE_WHILE_CONTINUE;
				}
				HistoryBuffer::push();
			COLORED_LINE_WHILE_END()
		}

		// SIDE-NOTE: Storing these command-line flags in a bit field and switching on it's value might have been a better way to do this in theory, because it's more efficient and might look better, but in practice, it might not have been the way to go.
		// It's not very scalable because you have to write out every single case (or use default, but that isn't applicable when you have complex relationships between cases and such). As soon as you have anywhere near something like 16 flags, your code bloat starts to become insane.
		// So I think the if statement approach is a good one, even though it's technically a very small bit less performant than the switch case approach.

		if (flags::inverted) {
			if (flags::only_line_nums) { LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { lineCounter++; LINE_WHILE_CONTINUE; } std::cout << lineCounter << '\n'; lineCounter++; LINE_WHILE_END() }
			if (flags::lineNums) { LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { lineCounter++; LINE_WHILE_CONTINUE; } std::cout << lineCounter << ' ' << CURRENT_LINE_ALIAS << '\n'; lineCounter++; LINE_WHILE_END() }
			LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { LINE_WHILE_CONTINUE } std::cout << CURRENT_LINE_ALIAS << '\n'; LINE_WHILE_END()
		}
		// TODO: The following ONLY_RED thing doesn't make sense when your running grep in interactive mode, because then your input text is also colored red, and everything is, and you can't tell where the hits are. So either reset every line, which is inefficient, or reset every line when your in interactive mode and when
		// we detect that stdin is a pipe connection, we can use the RED_ONLY method.
		// NOTE: I've fixed the above TODO, but it's a pretty dirty fix, you should probably clean up the code before you can call it totally fixed.
		if (flags::only_line_nums) {
			if (!forcedOutputColoring) {
				COLORED_RED_ONLY_LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { std::cout << lineCounter << '\n'; } lineCounter++; COLORED_RED_ONLY_LINE_WHILE_END
			}
			// TODO: Consider making other versions of the color variables that have newlines at the end so that you can avoid one of the << operators when using std::cout, I heard those were inefficient, check that claim out.
			COLORED_LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { std::cout << color::red << lineCounter << color::reset << '\n'; } lineCounter++; COLORED_LINE_WHILE_END()
		}
		if (flags::lineNums) { COLORED_LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { std::cout << color::red << lineCounter << color::reset << ' '; highlightMatches(); std::cout << CURRENT_LINE_ALIAS << '\n'; } lineCounter++; COLORED_LINE_WHILE_END() }
		COLORED_LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { highlightMatches(); std::cout << CURRENT_LINE_ALIAS << '\n'; } COLORED_LINE_WHILE_END()
	}

	if (flags::allLines) {
		if (flags::inverted) { return 0; }
		if (flags::only_line_nums) { MAIN_WHILE { INNER_INPUT_STREAM_DISCARD_LINE() std::cout << lineCounter << '\n'; lineCounter++; } }					// NOTE: At first glance, it looks like InputStream and HistoryBuffer aren't being released here, but they are. This code is completely fine.
		if (flags::lineNums) { LINE_WHILE_START std::cout << lineCounter << ' ' << CURRENT_LINE_ALIAS << '\n'; lineCounter++; LINE_WHILE_END() }
		LINE_WHILE_START std::cout << CURRENT_LINE_ALIAS << '\n'; LINE_WHILE_END()
	}

	if (flags::context) {
		if (flags::only_line_nums) {
			if (flags::inverted) {
				LINE_WHILE_START
					if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
						HistoryBuffer::purgeAmountFilled();
						lineCounter++;
						for (size_t afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; lineCounter < afterLastLineOfPadding; ) {
							INNER_WINDOWS_SIGNAL_CHECK_START
								CURRENT_LINE_ALIAS.clear();
								INNER_INPUT_STREAM_READ_LINE()
								if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { lineCounter++; afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; continue; }
								lineCounter++;
							INNER_WINDOWS_SIGNAL_CHECK_END()
						}
						LINE_WHILE_CONTINUE;
					}
					size_t safestLineNum; if (HistoryBuffer::peekSafestLineNum(safestLineNum)) { std::cout << safestLineNum << '\n'; }
					HistoryBuffer::incrementAmountFilled();
					lineCounter++;
				LINE_WHILE_END(HistoryBuffer::lastPrintLineNums())
			}
			LINE_WHILE_START
				if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
					HistoryBuffer::printLineNums();
					std::cout << lineCounter << '\n';
					lineCounter++;
					for (size_t afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; lineCounter < afterLastLineOfPadding; ) {
						INNER_WINDOWS_SIGNAL_CHECK_START
							CURRENT_LINE_ALIAS.clear();
							INNER_INPUT_STREAM_READ_LINE()
							std::cout << lineCounter << '\n';
							lineCounter++;
							if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; }
						INNER_WINDOWS_SIGNAL_CHECK_END()
					}
					LINE_WHILE_CONTINUE;
				}
				HistoryBuffer::incrementAmountFilled();
				lineCounter++;
			LINE_WHILE_END()
		}
		if (flags::lineNums) {
			if (flags::inverted) {
				LINE_WHILE_START
					if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
						HistoryBuffer::purgeWithAmountSet();
						lineCounter++;
						for (size_t afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; lineCounter < afterLastLineOfPadding; ) {
							INNER_WINDOWS_SIGNAL_CHECK_START
								CURRENT_LINE_ALIAS.clear();
								INNER_INPUT_STREAM_READ_LINE()
								if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { lineCounter++; afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; continue; }
								lineCounter++;
							INNER_WINDOWS_SIGNAL_CHECK_END()
						}
						LINE_WHILE_CONTINUE;
					}
					std::string safestLine;
					if (HistoryBuffer::peekSafestLine(safestLine)) {
						size_t safestLineNum; if (HistoryBuffer::peekSafestLineNum(safestLineNum)) { std::cout << safestLineNum << ' ' << safestLine << '\n'; }
					}
					HistoryBuffer::pushWithAmountInc();
					lineCounter++;
				LINE_WHILE_END(HistoryBuffer::printLinesWithLineNums())
			}
			LINE_WHILE_START
				if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
					HistoryBuffer::printLinesWithLineNums();
					std::cout << lineCounter << ' ' << CURRENT_LINE_ALIAS << '\n';
					lineCounter++;
					for (size_t afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; lineCounter < afterLastLineOfPadding; ) {
						INNER_WINDOWS_SIGNAL_CHECK_START
							CURRENT_LINE_ALIAS.clear();
							INNER_INPUT_STREAM_READ_LINE()
							std::cout << lineCounter << ' ' << CURRENT_LINE_ALIAS << '\n';
							lineCounter++;
							if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { afterLastLineOfPadding = lineCounter + HistoryBuffer::buffer_lastIndex; }
						INNER_WINDOWS_SIGNAL_CHECK_END()
					}
					LINE_WHILE_CONTINUE;
				}
				HistoryBuffer::push();
				lineCounter++;
			LINE_WHILE_END()
		}
		if (flags::inverted) {
			LINE_WHILE_START
				if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
					HistoryBuffer::purgeWithAmountSet();
					for (unsigned int padding = HistoryBuffer::buffer_lastIndex; padding > 0; ) {
						INNER_WINDOWS_SIGNAL_CHECK_START
							CURRENT_LINE_ALIAS.clear();
							INNER_INPUT_STREAM_READ_LINE()
							if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { padding = HistoryBuffer::buffer_lastIndex; continue; }
							padding--;
						INNER_WINDOWS_SIGNAL_CHECK_END()
					}
					LINE_WHILE_CONTINUE;
				}
				std::string safestLine; if (HistoryBuffer::peekSafestLine(safestLine)) { std::cout << safestLine << '\n'; }
				HistoryBuffer::pushWithAmountInc();
			LINE_WHILE_END(HistoryBuffer::print())
		}
		LINE_WHILE_START
			if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
				HistoryBuffer::print();
				std::cout << CURRENT_LINE_ALIAS << '\n';
				for (unsigned int padding = HistoryBuffer::buffer_lastIndex; padding > 0; ) {
					INNER_WINDOWS_SIGNAL_CHECK_START
						CURRENT_LINE_ALIAS.clear();
						INNER_INPUT_STREAM_READ_LINE()
						if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) {
							std::cout << CURRENT_LINE_ALIAS << '\n';
							padding = HistoryBuffer::buffer_lastIndex;
							continue;
						}
						std::cout << CURRENT_LINE_ALIAS << '\n';
						padding--;
					INNER_WINDOWS_SIGNAL_CHECK_END()
				}
				LINE_WHILE_CONTINUE;
			}
			HistoryBuffer::push();
		LINE_WHILE_END()
	}

	if (flags::inverted) {
		if (flags::only_line_nums) { LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { lineCounter++; LINE_WHILE_CONTINUE; } std::cout << lineCounter << '\n'; lineCounter++; LINE_WHILE_END() }
		if (flags::lineNums) { LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { lineCounter++; LINE_WHILE_CONTINUE; } std::cout << lineCounter << ' ' << CURRENT_LINE_ALIAS << '\n'; lineCounter++; LINE_WHILE_END() }
		LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { LINE_WHILE_CONTINUE; } std::cout << CURRENT_LINE_ALIAS << '\n'; LINE_WHILE_END()
	}
	if (flags::only_line_nums) { LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { std::cout << lineCounter << '\n'; } lineCounter++; LINE_WHILE_END() }
	if (flags::lineNums) { LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { std::cout << lineCounter << ' ' << CURRENT_LINE_ALIAS << '\n'; } lineCounter++; LINE_WHILE_END() }
	LINE_WHILE_START if (std::regex_search(CURRENT_LINE_ALIAS, matchData, keyphraseRegex)) { std::cout << CURRENT_LINE_ALIAS << '\n'; } LINE_WHILE_END()
}

/*

NOTE:

The Windows implementation relies on EOF being sent on SIGINT, but still uses the shouldLoopRun variable in case things don't go as planned, in order to still be able to exit eventually.
The problem with this approach is that in pipes where the first program doesn't listen to SIGINT and doesn't signal EOF to this grep program, this grep program wants to exit, but doesn't get to until a line is sent to it's stdin.
This problem doesn't exist in the Linux version because we intercept SIGINT in grep through polling a sig fd, which makes it instant, regardless of if data is available on stdin or not.
In order to do this in the Windows version (where such nice things as signalfd don't exist to my knowledge), I would need to do a whole lot of research and potentially some weird stuff.
Honestly, I'm too lazy for that right now and we're talking about something that, in all likelyhood, will never become a problem.
If it does become a problem, I'll just use the Windows findstr for that case.
For now, I'm just going to leave it like this.

*/

/*

NOTE:

There seems to be a bug in std::regex when using keyphrase ".*". When just doing match over the whole line and not highlighting, everything is fine, but for some reason, it gets stuck on match 0 and just keeps looping over and over.
You could say that it has to happen this way because, while it is strange, that behaviour makes the most sense based on the code above, but why is everything fine for keyphrase ".*k" then. Shouldn't the same problem apply there?

*/
